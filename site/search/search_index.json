{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"evrmore-rpc: Python Client for Evrmore Blockchain","text":"<p>A high-performance, production-grade Python client for the Evrmore blockchain. Built for developers who need reliability, performance, and comprehensive blockchain integration.</p>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>\ud83d\udd04 Context-Aware: Seamlessly switches between sync and async modes</li> <li>\u2699\ufe0f Flexible Configuration: Load from <code>evrmore.conf</code>, env vars, or manual args</li> <li>\ud83d\udca1 Complete RPC Coverage: Full method support with type hints</li> <li>\u26a1 High Performance: Connection pooling and optimized requests</li> <li>\ud83e\udde0 Asset Intelligence: Smart asset transaction parsing</li> <li>\ud83d\udce1 Real-Time Events: ZMQ notifications and WebSocket support</li> <li>\ud83e\uddf0 Developer Tools: Stress testing, coverage verification, and more</li> </ul>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Getting Started - Installation and basic usage</li> <li>API Reference - Complete API documentation</li> <li>ZMQ Guide - Real-time blockchain notifications</li> <li>WebSocket Guide - WebSocket integration</li> <li>Advanced Usage - Advanced patterns and best practices</li> <li>Examples - Code examples and tutorials</li> <li>Development - Contributing guide</li> </ul>"},{"location":"#use-cases","title":"\ud83c\udfaf Use Cases","text":"<ul> <li>Block Explorers: Real-time block and transaction monitoring</li> <li>Trading Platforms: Asset management and transaction processing</li> <li>Wallets: Address management and transaction signing</li> <li>Indexers: Efficient blockchain data extraction</li> <li>DEX Integration: Asset trading and order management</li> <li>Game Engines: In-game asset and reward systems</li> </ul>"},{"location":"#requirements","title":"\ud83d\udee0\ufe0f Requirements","text":"<ul> <li>Python 3.8+</li> <li>Evrmore daemon with RPC enabled</li> <li>Optional: ZMQ for real-time notifications</li> </ul>"},{"location":"#license","title":"\ud83e\udeaa License","text":"<p>MIT License \u2014 See LICENSE</p>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! See our Development Guide for details.</p> <pre><code>git clone https://github.com/manticoretechnologies/evrmore-rpc-dev\ncd evrmore-rpc\npython3 -m venv .venv &amp;&amp; source .venv/bin/activate\npip install -e .[dev]\n</code></pre>"},{"location":"advanced/","title":"Advanced Usage Guide","text":"<p>This guide covers advanced features and production patterns for the <code>evrmore-rpc</code> package.</p>"},{"location":"advanced/#connection-management","title":"Connection Management","text":""},{"location":"advanced/#connection-pooling","title":"Connection Pooling","text":"<pre><code>from evrmore_rpc import EvrmoreClient, ConnectionPool\n\n# Create connection pool\npool = ConnectionPool(\n    host=\"127.0.0.1\",\n    port=8332,\n    username=\"rpcuser\",\n    password=\"rpcpass\",\n    max_connections=10,\n    timeout=30\n)\n\n# Get client from pool\nclient = pool.get_client()\n\ntry:\n    # Use client\n    result = client.getblockchaininfo()\nfinally:\n    # Always return client to pool\n    pool.return_client(client)\n</code></pre>"},{"location":"advanced/#context-managers","title":"Context Managers","text":"<pre><code># Using context manager\nwith pool.get_client() as client:\n    result = client.getblockchaininfo()\n\n# Custom context manager\nclass EvrmoreContext:\n    def __init__(self, host=\"127.0.0.1\", port=8332):\n        self.client = EvrmoreClient(host=host, port=port)\n\n    def __enter__(self):\n        return self.client\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.client.close()\n\n# Usage\nwith EvrmoreContext() as client:\n    result = client.getblockchaininfo()\n</code></pre>"},{"location":"advanced/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/#batch-processing","title":"Batch Processing","text":"<pre><code>def process_blocks(start_height, end_height, batch_size=100):\n    for i in range(start_height, end_height + 1, batch_size):\n        batch_end = min(i + batch_size, end_height + 1)\n        blocks = []\n\n        for height in range(i, batch_end):\n            block = client.getblock(height)\n            blocks.append(block)\n\n        # Process batch\n        process_block_batch(blocks)\n\ndef process_block_batch(blocks):\n    for block in blocks:\n        # Process block data\n        pass\n</code></pre>"},{"location":"advanced/#caching","title":"Caching","text":"<pre><code>from functools import lru_cache\nimport time\n\nclass CachedEvrmoreClient:\n    def __init__(self, client):\n        self.client = client\n        self.block_cache = {}\n        self.tx_cache = {}\n\n    @lru_cache(maxsize=1000)\n    def get_block(self, height):\n        return self.client.getblock(height)\n\n    @lru_cache(maxsize=10000)\n    def get_transaction(self, txid):\n        return self.client.getrawtransaction(txid, True)\n\n    def clear_cache(self):\n        self.get_block.cache_clear()\n        self.get_transaction.cache_clear()\n</code></pre>"},{"location":"advanced/#error-handling","title":"Error Handling","text":""},{"location":"advanced/#custom-error-classes","title":"Custom Error Classes","text":"<pre><code>from evrmore_rpc import EvrmoreRPCError\n\nclass EvrmoreClientError(Exception):\n    \"\"\"Base class for Evrmore client errors\"\"\"\n    pass\n\nclass BlockNotFoundError(EvrmoreClientError):\n    \"\"\"Raised when a block is not found\"\"\"\n    pass\n\nclass TransactionNotFoundError(EvrmoreClientError):\n    \"\"\"Raised when a transaction is not found\"\"\"\n    pass\n\ndef get_block_safe(height):\n    try:\n        return client.getblock(height)\n    except EvrmoreRPCError as e:\n        if \"Block not found\" in str(e):\n            raise BlockNotFoundError(f\"Block at height {height} not found\")\n        raise\n</code></pre>"},{"location":"advanced/#retry-logic","title":"Retry Logic","text":"<pre><code>from tenacity import retry, stop_after_attempt, wait_exponential\n\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=4, max=10)\n)\ndef get_block_with_retry(height):\n    return client.getblock(height)\n</code></pre>"},{"location":"advanced/#real-time-processing","title":"Real-Time Processing","text":""},{"location":"advanced/#zmq-integration","title":"ZMQ Integration","text":"<pre><code>from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\nclass BlockchainProcessor:\n    def __init__(self):\n        self.zmq = EvrmoreZMQClient()\n        self.rpc = EvrmoreClient()\n        self.blocks_processed = 0\n        self.transactions_processed = 0\n\n    def start(self):\n        # Register handlers\n        self.zmq.on_block(self.handle_block)\n        self.zmq.on_transaction(self.handle_transaction)\n\n        # Start ZMQ client\n        self.zmq.start()\n\n    def handle_block(self, notification):\n        block = self.rpc.getblock(notification.hex)\n        self.blocks_processed += 1\n\n        # Process block\n        self.process_block(block)\n\n    def handle_transaction(self, notification):\n        tx = self.rpc.getrawtransaction(notification.hex, True)\n        self.transactions_processed += 1\n\n        # Process transaction\n        self.process_transaction(tx)\n</code></pre>"},{"location":"advanced/#websocket-integration","title":"WebSocket Integration","text":"<pre><code>from evrmore_rpc.websocket import EvrmoreWebSocketClient, WebSocketTopic\n\nclass BlockchainMonitor:\n    def __init__(self):\n        self.ws = EvrmoreWebSocketClient()\n        self.rpc = EvrmoreClient()\n        self.blocks_processed = 0\n        self.transactions_processed = 0\n\n    async def start(self):\n        # Register handlers\n        self.ws.on_block(self.handle_block)\n        self.ws.on_transaction(self.handle_transaction)\n\n        # Start WebSocket client\n        await self.ws.start()\n\n    async def handle_block(self, notification):\n        block = self.rpc.getblock(notification.hash)\n        self.blocks_processed += 1\n\n        # Process block\n        await self.process_block(block)\n\n    async def handle_transaction(self, notification):\n        tx = self.rpc.getrawtransaction(notification.txid, True)\n        self.transactions_processed += 1\n\n        # Process transaction\n        await self.process_transaction(tx)\n</code></pre>"},{"location":"advanced/#asset-management","title":"Asset Management","text":""},{"location":"advanced/#asset-tracking","title":"Asset Tracking","text":"<pre><code>class AssetTracker:\n    def __init__(self):\n        self.client = EvrmoreClient()\n        self.assets = {}\n\n    def track_asset(self, asset_name):\n        # Get asset info\n        asset = self.client.getassetinfo(asset_name)\n        self.assets[asset_name] = {\n            \"name\": asset.name,\n            \"amount\": asset.amount,\n            \"units\": asset.units,\n            \"reissuable\": asset.reissuable,\n            \"transfers\": []\n        }\n\n    def get_asset_transfers(self, asset_name, start_block=0):\n        if asset_name not in self.assets:\n            self.track_asset(asset_name)\n\n        current_height = self.client.getblockcount()\n\n        for height in range(start_block, current_height + 1):\n            block = self.client.getblock(height)\n\n            for txid in block.tx:\n                tx = self.client.getrawtransaction(txid, True)\n\n                for vout in tx.vout:\n                    if \"asset\" in vout.get(\"scriptPubKey\", {}).get(\"asset\", {}):\n                        asset = vout[\"scriptPubKey\"][\"asset\"]\n                        if asset[\"name\"] == asset_name:\n                            self.assets[asset_name][\"transfers\"].append({\n                                \"txid\": txid,\n                                \"amount\": asset[\"amount\"],\n                                \"block\": height,\n                                \"time\": block.time\n                            })\n</code></pre>"},{"location":"advanced/#asset-issuance","title":"Asset Issuance","text":"<pre><code>class AssetIssuer:\n    def __init__(self):\n        self.client = EvrmoreClient()\n\n    def issue_asset(self, name, amount, units=0, reissuable=True, ipfs_hash=None):\n        # Issue new asset\n        txid = self.client.issueasset(\n            name=name,\n            amount=amount,\n            units=units,\n            reissuable=reissuable,\n            ipfs_hash=ipfs_hash\n        )\n\n        # Wait for confirmation\n        self.wait_for_confirmation(txid)\n\n        return txid\n\n    def reissue_asset(self, name, amount, ipfs_hash=None):\n        # Reissue existing asset\n        txid = self.client.reissueasset(\n            name=name,\n            amount=amount,\n            ipfs_hash=ipfs_hash\n        )\n\n        # Wait for confirmation\n        self.wait_for_confirmation(txid)\n\n        return txid\n\n    def wait_for_confirmation(self, txid, confirmations=1):\n        while True:\n            tx = self.client.getrawtransaction(txid, True)\n            if tx.confirmations &gt;= confirmations:\n                break\n            time.sleep(1)\n</code></pre>"},{"location":"advanced/#production-patterns","title":"Production Patterns","text":""},{"location":"advanced/#logging","title":"Logging","text":"<pre><code>import logging\n\nclass EvrmoreLogger:\n    def __init__(self):\n        self.logger = logging.getLogger(\"evrmore\")\n        self.logger.setLevel(logging.INFO)\n\n        # Add handlers\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n\n    def log_block(self, block):\n        self.logger.info(f\"Processing block {block.height}\")\n\n    def log_transaction(self, tx):\n        self.logger.info(f\"Processing transaction {tx.txid}\")\n\n    def log_error(self, error):\n        self.logger.error(f\"Error: {error}\")\n</code></pre>"},{"location":"advanced/#metrics-collection","title":"Metrics Collection","text":"<pre><code>from prometheus_client import Counter, Gauge, start_http_server\n\nclass EvrmoreMetrics:\n    def __init__(self):\n        # Counters\n        self.blocks_processed = Counter(\n            'evrmore_blocks_processed_total',\n            'Total number of blocks processed'\n        )\n        self.transactions_processed = Counter(\n            'evrmore_transactions_processed_total',\n            'Total number of transactions processed'\n        )\n\n        # Gauges\n        self.current_height = Gauge(\n            'evrmore_current_height',\n            'Current blockchain height'\n        )\n        self.connection_status = Gauge(\n            'evrmore_connection_status',\n            'Connection status (1=connected, 0=disconnected)'\n        )\n\n    def start_server(self, port=8000):\n        start_http_server(port)\n\n    def update_metrics(self, client):\n        info = client.getblockchaininfo()\n        self.current_height.set(info.blocks)\n        self.connection_status.set(1)\n</code></pre>"},{"location":"advanced/#health-checks","title":"Health Checks","text":"<pre><code>class EvrmoreHealth:\n    def __init__(self):\n        self.client = EvrmoreClient()\n        self.last_check = 0\n        self.check_interval = 60  # seconds\n\n    def is_healthy(self):\n        current_time = time.time()\n        if current_time - self.last_check &lt; self.check_interval:\n            return True\n\n        try:\n            # Check connection\n            self.client.getblockchaininfo()\n            self.last_check = current_time\n            return True\n        except Exception as e:\n            return False\n\n    def get_status(self):\n        try:\n            info = self.client.getblockchaininfo()\n            return {\n                \"status\": \"healthy\",\n                \"blocks\": info.blocks,\n                \"headers\": info.headers,\n                \"verification_progress\": info.verificationprogress\n            }\n        except Exception as e:\n            return {\n                \"status\": \"unhealthy\",\n                \"error\": str(e)\n            }\n</code></pre>"},{"location":"advanced/#see-also","title":"See Also","text":"<ul> <li>Getting Started for basic usage</li> <li>API Reference for detailed API docs</li> <li>Examples for code samples</li> <li>ZMQ Guide for real-time notifications</li> <li>WebSocket Guide for WebSocket integration </li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>This document provides a comprehensive reference for the <code>evrmore-rpc</code> Python package.</p>"},{"location":"api-reference/#core-classes","title":"Core Classes","text":""},{"location":"api-reference/#evrmoreclient","title":"EvrmoreClient","text":"<p>The main client class for interacting with the Evrmore blockchain.</p> <pre><code>from evrmore_rpc import EvrmoreClient\n\nclient = EvrmoreClient()\n</code></pre>"},{"location":"api-reference/#configuration","title":"Configuration","text":"<pre><code>client = EvrmoreClient(\n    url=\"http://localhost:8819\",      # RPC URL\n    rpcuser=\"user\",                   # RPC username\n    rpcpassword=\"pass\",               # RPC password\n    rpcport=8819,                     # RPC port\n    testnet=True,                     # Use testnet\n    timeout=30,                       # Request timeout\n    async_mode=None                   # Auto-detect or force sync/async\n)\n</code></pre>"},{"location":"api-reference/#key-methods","title":"Key Methods","text":""},{"location":"api-reference/#blockchain","title":"Blockchain","text":"<pre><code># Get blockchain info\ninfo = client.getblockchaininfo()\n\n# Get block by height\nblock_hash = client.getblockhash(height)\nblock = client.getblock(block_hash)\n\n# Get mempool info\nmempool = client.getmempoolinfo()\n</code></pre>"},{"location":"api-reference/#assets","title":"Assets","text":"<pre><code># Get asset data\ninfo = client.getassetdata(\"ASSET_NAME\")\n\n# Transfer asset\ntxid = client.transfer(\"ASSET_NAME\", amount, \"ADDRESS\")\n\n# Issue asset\ntxid = client.issue(\n    \"ASSET_NAME\",\n    qty=1000,\n    to_address=\"ADDRESS\",\n    units=0,\n    reissuable=True\n)\n</code></pre>"},{"location":"api-reference/#transactions","title":"Transactions","text":"<pre><code># Get transaction\ntx = client.getrawtransaction(\"TXID\", True)\n\n# Send transaction\ntxid = client.sendrawtransaction(\"HEX\")\n\n# Create transaction\nraw_tx = client.createrawtransaction(\n    [{\"txid\": \"TXID\", \"vout\": 0}],\n    {\"ADDRESS\": 0.1}\n)\n</code></pre>"},{"location":"api-reference/#wallet","title":"Wallet","text":"<pre><code># Get balance\nbalance = client.getbalance()\n\n# Send to address\ntxid = client.sendtoaddress(\"ADDRESS\", 0.1)\n\n# Get new address\naddress = client.getnewaddress()\n</code></pre>"},{"location":"api-reference/#evrmorezmqclient","title":"EvrmoreZMQClient","text":"<p>Client for receiving real-time blockchain notifications via ZMQ.</p> <pre><code>from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\nzmq = EvrmoreZMQClient(\n    zmq_host=\"127.0.0.1\",\n    zmq_port=28332,\n    topics=[ZMQTopic.BLOCK, ZMQTopic.TX],\n    rpc_client=client,\n    auto_decode=True\n)\n</code></pre>"},{"location":"api-reference/#event-handlers","title":"Event Handlers","text":"<pre><code>@zmq.on(ZMQTopic.BLOCK)\ndef handle_block(notification):\n    print(f\"Block #{notification.height}\")\n\n@zmq.on(ZMQTopic.TX)\ndef handle_tx(notification):\n    print(f\"TX {notification.tx['txid']}\")\n</code></pre>"},{"location":"api-reference/#evrmorewebsocketclient","title":"EvrmoreWebSocketClient","text":"<p>Client for WebSocket-based blockchain notifications.</p> <pre><code>from evrmore_rpc.websockets import EvrmoreWebSocketClient\n\nws = EvrmoreWebSocketClient(uri=\"ws://localhost:8765\")\n</code></pre>"},{"location":"api-reference/#usage","title":"Usage","text":"<pre><code>async def main():\n    await ws.connect()\n    await ws.subscribe(\"blocks\")\n\n    async for message in ws:\n        print(f\"{message.type}: {message.data}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"api-reference/#data-models","title":"Data Models","text":"<p>All RPC responses are automatically parsed into Pydantic models for type safety and validation.</p>"},{"location":"api-reference/#block-model","title":"Block Model","text":"<pre><code>class Block(BaseModel):\n    hash: str\n    height: int\n    time: int\n    size: int\n    tx: List[str]\n    # ... other fields\n</code></pre>"},{"location":"api-reference/#transaction-model","title":"Transaction Model","text":"<pre><code>class Transaction(BaseModel):\n    txid: str\n    size: int\n    vsize: int\n    version: int\n    locktime: int\n    vin: List[Vin]\n    vout: List[Vout]\n    # ... other fields\n</code></pre>"},{"location":"api-reference/#asset-model","title":"Asset Model","text":"<pre><code>class Asset(BaseModel):\n    name: str\n    amount: int\n    units: int\n    reissuable: bool\n    has_ipfs: bool\n    ipfs_hash: Optional[str]\n    # ... other fields\n</code></pre>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":"<p>The client raises specific exceptions for different error types:</p> <pre><code>from evrmore_rpc import EvrmoreRPCError\n\ntry:\n    client.getblockchaininfo()\nexcept EvrmoreRPCError as e:\n    print(f\"RPC error: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"api-reference/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api-reference/#connection-pooling","title":"Connection Pooling","text":"<p>The client automatically uses connection pooling for better performance:</p> <pre><code># Create a client with custom pool size\nclient = EvrmoreClient(pool_size=10)\n\n# The pool is automatically managed\ninfo = client.getblockchaininfo()\n</code></pre>"},{"location":"api-reference/#batch-processing","title":"Batch Processing","text":"<p>For processing multiple blocks or transactions:</p> <pre><code>async def process_blocks(start_height, end_height):\n    async with EvrmoreClient() as client:\n        for height in range(start_height, end_height):\n            block_hash = await client.getblockhash(height)\n            block = await client.getblock(block_hash)\n            # Process block\n</code></pre>"},{"location":"api-reference/#see-also","title":"See Also","text":"<ul> <li>Getting Started for installation and basic usage</li> <li>Examples for more code samples</li> <li>Advanced Usage for production patterns</li> <li>Development for contributing </li> </ul>"},{"location":"api/","title":"Api","text":""},{"location":"api/#zmq-client-api","title":"ZMQ Client API","text":"<p>The ZMQ client provides a seamless API that works in both synchronous and asynchronous contexts.</p>"},{"location":"api/#initialization","title":"Initialization","text":"<pre><code>from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\n# Default initialization\nzmq = EvrmoreZMQClient()  # Default host: 127.0.0.1, port: 28332\n\n# Custom ZMQ endpoint\nzmq = EvrmoreZMQClient(zmq_host=\"192.168.1.100\", zmq_port=28333)\n\n# Specific topics (default is all topics)\nzmq = EvrmoreZMQClient(topics=[ZMQTopic.HASH_BLOCK, ZMQTopic.HASH_TX])\n</code></pre>"},{"location":"api/#configuration","title":"Configuration","text":"<pre><code># Set lingering time for fast shutdown (0 = no lingering)\nzmq.set_lingering(0)\n\n# Set cleanup timeouts for graceful shutdown\nzmq.set_cleanup_timeouts(thread_timeout=0.1, task_timeout=0.1)\n\n# Force synchronous mode regardless of context\nzmq.force_sync()\n\n# Force asynchronous mode regardless of context\nzmq.force_async()\n\n# Reset to auto-detect mode (default behavior)\nzmq.reset()\n</code></pre>"},{"location":"api/#starting-and-stopping","title":"Starting and Stopping","text":"<pre><code># Start the client - works in both sync and async contexts\nzmq.start()  # In sync context\nawait zmq.start()  # In async context\n\n# Stop the client - works in both sync and async contexts\nzmq.stop()  # In sync context\nawait zmq.stop()  # In async context\n\n# Force immediate exit (for emergencies)\nzmq.stop(force=True)  # Exits program immediately\n</code></pre>"},{"location":"api/#event-handlers","title":"Event Handlers","text":"<pre><code># Register a handler for a topic with decorator\n@zmq.on(ZMQTopic.HASH_BLOCK)\ndef on_new_block(notification):\n    print(f\"New block: {notification.hex}\")\n\n@zmq.on(ZMQTopic.HASH_TX)\ndef on_new_tx(notification):\n    print(f\"New transaction: {notification.hex}\")\n</code></pre>"},{"location":"api/#example-zmq-synchronous-usage","title":"Example: ZMQ Synchronous Usage","text":"<p>```python import signal import sys import time from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic</p>"},{"location":"api/#initialize-client","title":"Initialize client","text":"<p>zmq = EvrmoreZMQClient() zmq.set_lingering(0)  # For fast shutdown</p>"},{"location":"api/#handle-ctrlc-for-clean-shutdown","title":"Handle Ctrl+C for clean shutdown","text":"<p>def signal_handler(sig, frame):     print(\"\\nShutting down...\")     zmq.stop()     print(\"Goodbye!\")     sys.exit(0)</p> <p>signal.signal(signal.SIGINT, signal_handler)</p>"},{"location":"api/#register-handlers","title":"Register handlers","text":"<p>@zmq.on(ZMQTopic.HASH_BLOCK) def on_new_block(notification):     print(f\"New block: {notification.hex}\")</p> <p>@zmq.on(ZMQTopic.HASH_TX) def on_new_transaction(notification):     print(f\"New transaction: {notification.hex}\")</p>"},{"location":"api/#start-the-client","title":"Start the client","text":"<p>zmq.start()</p>"},{"location":"api/#main-loop","title":"Main loop","text":"<p>try:     while True:         print(\"Waiting for events...\")         time.sleep(5) except KeyboardInterrupt:     print(\"\\nShutting down...\")     zmq.stop()</p>"},{"location":"api/#example-zmq-asynchronous-usage","title":"Example: ZMQ Asynchronous Usage","text":"<p>```python import asyncio import signal import sys from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic</p>"},{"location":"api/#create-event-for-shutdown","title":"Create event for shutdown","text":"<p>shutdown_event = asyncio.Event()</p>"},{"location":"api/#signal-handler-for-ctrlc","title":"Signal handler for Ctrl+C","text":"<p>def signal_handler(sig, frame):     print(\"\\nShutdown initiated...\")     if not shutdown_event.is_set():         shutdown_event.set()</p> <p>signal.signal(signal.SIGINT, signal_handler)</p> <p>async def main():     # Initialize client     zmq = EvrmoreZMQClient()     zmq.set_lingering(0)  # For fast shutdown</p> <pre><code># Register handlers\n@zmq.on(ZMQTopic.HASH_BLOCK)\ndef on_new_block(notification):\n    print(f\"New block: {notification.hex}\")\n\n@zmq.on(ZMQTopic.HASH_TX)\ndef on_new_transaction(notification):\n    print(f\"New transaction: {notification.hex}\")\n\n# Start the client\nawait zmq.start()\n\ntry:\n    # Wait for shutdown signal\n    while not shutdown_event.is_set():\n        print(\"Waiting for events...\")\n        try:\n            await asyncio.wait_for(shutdown_event.wait(), timeout=5)\n        except asyncio.TimeoutError:\n            continue\nexcept asyncio.CancelledError:\n    pass\nfinally:\n    # Stop the client\n    await zmq.stop()\n    print(\"Client stopped cleanly.\")\n</code></pre>"},{"location":"api/#run-the-main-function","title":"Run the main function","text":"<p>if name == \"main\":     try:         asyncio.run(main())         print(\"Clean exit.\")     except KeyboardInterrupt:         print(\"Forced exit.\")</p>"},{"location":"api/#example-emergency-fast-exit","title":"Example: Emergency Fast Exit","text":"<p>```python import signal import sys from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic</p>"},{"location":"api/#initialize-client_1","title":"Initialize client","text":"<p>zmq = EvrmoreZMQClient() zmq.set_lingering(0)  # Try to set fast shutdown</p>"},{"location":"api/#track-if-first-ctrlc-press","title":"Track if first Ctrl+C press","text":"<p>first_interrupt = True</p>"},{"location":"api/#handle-ctrlc","title":"Handle Ctrl+C","text":"<p>def signal_handler(sig, frame):     global first_interrupt</p> <pre><code>if first_interrupt:\n    print(\"\\nPress Ctrl+C again for immediate exit\")\n    print(\"Attempting normal shutdown...\")\n    first_interrupt = False\n    zmq.stop()  # Try normal shutdown\nelse:\n    print(\"\\nForce exiting immediately!\")\n    zmq.stop(force=True)  # Force immediate exit\n</code></pre> <p>signal.signal(signal.SIGINT, signal_handler)</p>"},{"location":"api/#register-handler","title":"Register handler","text":"<p>@zmq.on(ZMQTopic.HASH_BLOCK) def on_new_block(notification):     print(f\"New block: {notification.hex}\")</p>"},{"location":"api/#start-the-client_1","title":"Start the client","text":"<p>zmq.start()</p>"},{"location":"api/#main-loop-never-reached-with-double-ctrlc","title":"Main loop (never reached with double Ctrl+C)","text":"<p>print(\"Press Ctrl+C once for normal exit, twice for immediate exit\") try:     import time     while True:         time.sleep(1) except Exception:     pass </p>"},{"location":"api_reference/","title":"API Reference","text":"<p>This page documents the main classes and methods of the <code>evrmore-rpc</code> Python package.</p>"},{"location":"api_reference/#overview","title":"Overview","text":"<p>The <code>evrmore-rpc</code> library provides a full-featured, production-grade API for interacting with the Evrmore blockchain. It supports:</p> <ul> <li>Synchronous and Asynchronous Clients: Choose between <code>EvrmoreClient</code> or <code>EvrmoreAsyncRPCClient</code>.</li> <li>ZMQ Notifications: Stream real-time block and transaction data.</li> <li>WebSockets: Push blockchain data to clients with subscription support.</li> <li>Typed Models: Built with Pydantic for strong typing and validation.</li> <li>Flexible Configuration: Works out-of-the-box with <code>evrmore.conf</code>, env vars, or direct credentials.</li> </ul>"},{"location":"api_reference/#main-classes","title":"\ud83d\ude80 Main Classes","text":"Class Description Import Path <code>EvrmoreClient</code> Main synchronous client <code>from evrmore_rpc import EvrmoreClient</code> <code>EvrmoreZMQClient</code> ZMQ notifications client <code>from evrmore_rpc.zmq import EvrmoreZMQClient</code> <code>EvrmoreWebSocketClient</code> WebSocket client <code>from evrmore_rpc.websockets import EvrmoreWebSocketClient</code> <code>EvrmoreWebSocketServer</code> WebSocket server <code>from evrmore_rpc.websockets import EvrmoreWebSocketServer</code>"},{"location":"api_reference/#quick-example","title":"\ud83e\uddea Quick Example","text":"<pre><code>from evrmore_rpc import EvrmoreClient\n\n# Create a client\nclient = EvrmoreClient()\n\n# Get blockchain info\ninfo = client.getblockchaininfo()\nprint(f\"Current block height: {info.blocks}\")\nprint(f\"Chain: {info.chain}\")\nprint(f\"Difficulty: {info.difficulty}\")\n\n# Get a specific block\nblock_hash = client.getblockhash(1)\nblock = client.getblock(block_hash)\nprint(f\"Block #1 hash: {block.hash}\")\nprint(f\"Block #1 time: {block.time}\")\nprint(f\"Block #1 transactions: {len(block.tx)}\")\n</code></pre>"},{"location":"api_reference/#design-philosophy","title":"\ud83e\udde0 Design Philosophy","text":"<ul> <li>\u2705 Type Safety: All methods return validated, documented models using Pydantic.</li> <li>\ud83d\udd01 Context Awareness: Clients auto-adapt to sync/async environments.</li> <li>\u26a1 Performance First: Fast connection pooling, minimal overhead.</li> <li>\ud83d\udd10 Secure Defaults: Supports <code>.cookie</code> auth, encrypted RPC, and env-based credentials.</li> <li>\ud83e\udde9 Composable: All classes and utilities are modular and extendable.</li> </ul>"},{"location":"api_reference/#explore-more","title":"\ud83d\udd0e Explore More","text":"<ul> <li>Synchronous API: Traditional blocking usage via <code>EvrmoreClient</code></li> <li>Asynchronous API: Async/await programming via <code>EvrmoreAsyncRPCClient</code></li> <li>ZMQ Support: Realtime blockchain streaming with <code>EvrmoreZMQClient</code></li> <li>WebSockets Support: Pub-sub architecture using <code>EvrmoreWebSocketServer</code></li> <li>Data Models: Full list of typed structures returned from RPC</li> <li>Usage Examples: Dashboards, stress tests, DEX logic, more</li> </ul> <p>For additional CLI usage, performance benchmarks, and integrations, check the README and the <code>examples/</code> directory.</p>"},{"location":"development/","title":"Development Guide","text":"<p>This guide covers how to contribute to the <code>evrmore-rpc</code> package.</p>"},{"location":"development/#development-setup","title":"Development Setup","text":""},{"location":"development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>Git</li> <li>Virtual environment (recommended)</li> <li>Evrmore node with RPC enabled</li> </ul>"},{"location":"development/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/manticoretechnologies/evrmore-rpc-dev.git\ncd evrmore-rpc\n</code></pre>"},{"location":"development/#create-virtual-environment","title":"Create Virtual Environment","text":"<pre><code># Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# On Windows:\nvenv\\Scripts\\activate\n# On Unix or MacOS:\nsource venv/bin/activate\n</code></pre>"},{"location":"development/#install-dependencies","title":"Install Dependencies","text":"<pre><code># Install development dependencies\npip install -e \".[dev]\"\n\n# Install pre-commit hooks\npre-commit install\n</code></pre>"},{"location":"development/#code-style","title":"Code Style","text":""},{"location":"development/#python-style-guide","title":"Python Style Guide","text":"<p>We follow PEP 8 style guide for Python code. Use the following tools to ensure code quality:</p> <pre><code># Run linter\nflake8\n\n# Run type checker\nmypy\n\n# Run formatter\nblack .\n\n# Run isort\nisort .\n</code></pre>"},{"location":"development/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>The following pre-commit hooks are configured:</p> <ul> <li><code>black</code>: Code formatting</li> <li><code>isort</code>: Import sorting</li> <li><code>flake8</code>: Linting</li> <li><code>mypy</code>: Type checking</li> <li><code>pytest</code>: Unit tests</li> </ul>"},{"location":"development/#testing","title":"Testing","text":""},{"location":"development/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run specific test file\npytest tests/test_client.py\n\n# Run tests with coverage\npytest --cov=evrmore_rpc\n\n# Run tests with verbose output\npytest -v\n</code></pre>"},{"location":"development/#writing-tests","title":"Writing Tests","text":"<ul> <li>Place test files in the <code>tests</code> directory</li> <li>Name test files with <code>test_</code> prefix</li> <li>Use descriptive test names</li> <li>Follow the Arrange-Act-Assert pattern</li> <li>Use fixtures for common setup</li> </ul> <p>Example test:</p> <pre><code>import pytest\nfrom evrmore_rpc import EvrmoreClient\n\ndef test_get_blockchain_info():\n    # Arrange\n    client = EvrmoreClient()\n\n    # Act\n    info = client.getblockchaininfo()\n\n    # Assert\n    assert info.blocks &gt;= 0\n    assert info.headers &gt;= 0\n    assert info.bestblockhash is not None\n</code></pre>"},{"location":"development/#documentation","title":"Documentation","text":""},{"location":"development/#building-documentation","title":"Building Documentation","text":"<pre><code># Install documentation dependencies\npip install -e \".[docs]\"\n\n# Build documentation\ncd docs\nmake html\n</code></pre>"},{"location":"development/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use Markdown for documentation files</li> <li>Follow the existing documentation structure</li> <li>Include code examples</li> <li>Add type hints to all functions</li> <li>Document all parameters and return values</li> <li>Keep documentation up to date with code changes</li> </ul> <p>Example docstring:</p> <pre><code>def get_block(height: int) -&gt; Block:\n    \"\"\"Get block information by height.\n\n    Args:\n        height: Block height to retrieve.\n\n    Returns:\n        Block object containing block information.\n\n    Raises:\n        EvrmoreRPCError: If the RPC call fails.\n        BlockNotFoundError: If the block is not found.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"development/#pull-requests","title":"Pull Requests","text":""},{"location":"development/#creating-a-pull-request","title":"Creating a Pull Request","text":"<ol> <li>Create a new branch for your changes</li> <li>Make your changes</li> <li>Run tests and ensure they pass</li> <li>Update documentation if needed</li> <li>Create a pull request</li> </ol>"},{"location":"development/#pull-request-checklist","title":"Pull Request Checklist","text":"<ul> <li> Tests added/updated</li> <li> Documentation updated</li> <li> Code style follows project guidelines</li> <li> All tests pass</li> <li> Pre-commit hooks pass</li> <li> Type hints added/updated</li> <li> Changelog updated</li> </ul>"},{"location":"development/#release-process","title":"Release Process","text":""},{"location":"development/#versioning","title":"Versioning","text":"<p>We follow semantic versioning (MAJOR.MINOR.PATCH):</p> <ul> <li>MAJOR: Breaking changes</li> <li>MINOR: New features, backward compatible</li> <li>PATCH: Bug fixes, backward compatible</li> </ul>"},{"location":"development/#creating-a-release","title":"Creating a Release","text":"<ol> <li>Update version in <code>setup.py</code></li> <li>Update changelog</li> <li>Create release tag</li> <li>Build and upload to PyPI</li> </ol> <pre><code># Update version\nsed -i 's/version=\".*\"/version=\"1.0.0\"/' setup.py\n\n# Create tag\ngit tag -a v1.0.0 -m \"Release v1.0.0\"\ngit push origin v1.0.0\n\n# Build and upload\npython -m build\ntwine upload dist/*\n</code></pre>"},{"location":"development/#project-structure","title":"Project Structure","text":"<pre><code>evrmore-rpc/\n\u251c\u2500\u2500 docs/                  # Documentation\n\u251c\u2500\u2500 evrmore_rpc/          # Source code\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 client.py         # Main client\n\u2502   \u251c\u2500\u2500 zmq.py            # ZMQ client\n\u2502   \u251c\u2500\u2500 websocket.py      # WebSocket client\n\u2502   \u2514\u2500\u2500 models.py         # Data models\n\u251c\u2500\u2500 tests/                # Test files\n\u251c\u2500\u2500 setup.py             # Package setup\n\u251c\u2500\u2500 pyproject.toml       # Project configuration\n\u251c\u2500\u2500 README.md            # Project readme\n\u2514\u2500\u2500 CHANGELOG.md         # Version history\n</code></pre>"},{"location":"development/#see-also","title":"See Also","text":"<ul> <li>Getting Started for basic usage</li> <li>API Reference for detailed API docs</li> <li>Examples for code samples</li> <li>Advanced Usage for production patterns </li> </ul>"},{"location":"examples/","title":"evrmore-rpc: Python Client for Evrmore Blockchain","text":"<p>A high-performance, full-featured Python client for the Evrmore blockchain. Designed for real-world applications like wallets, explorers, and exchanges, it includes synchronous and asynchronous RPC support, auto-decoding ZMQ streams, typed WebSocket communication, structured data models, and powerful developer tools.</p>"},{"location":"examples/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>\ud83d\udd04 Context-Aware: Auto-adapts between sync and async execution</li> <li>\u2699\ufe0f Flexible Config: Load from <code>evrmore.conf</code>, environment, or arguments</li> <li>\ud83d\udd10 Cookie &amp; Auth: Supports <code>.cookie</code> file and manual RPC credentials</li> <li>\ud83d\udca1 Typed RPC Coverage: All RPC methods typed with Pydantic models</li> <li>\u26a1 Connection Pooling: Fast RPC calls with keep-alive sessions</li> <li>\ud83e\udde0 Asset Intelligence: Decodes asset transactions, supply, metadata</li> <li>\ud83d\udce1 ZMQ Real-Time Streams: HASH_, RAW_, BLOCK, TX w/ decoding</li> <li>\ud83c\udf10 WebSocket Support: Realtime server and client push subscriptions</li> <li>\ud83d\udcca CLI &amp; Stress Tools: Benchmark, test, and audit performance</li> <li>\ud83e\uddea Extensive Examples: From zero to production-ready integrations</li> </ul>"},{"location":"examples/#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip install evrmore-rpc\n</code></pre> <p>Optional extras:</p> <pre><code>pip install evrmore-rpc[websockets]     # For WebSocket support\npip install evrmore-rpc[full]           # All optional dependencies\n</code></pre>"},{"location":"examples/#quick-start","title":"\ud83e\uddea Quick Start","text":"<pre><code>from evrmore_rpc import EvrmoreClient\n\nclient = EvrmoreClient()\ninfo = client.getblockchaininfo()\nprint(\"Height:\", info['blocks'])\n</code></pre>"},{"location":"examples/#synchronous-api-example","title":"\ud83e\udded Synchronous API Example","text":"<pre><code>from evrmore_rpc import EvrmoreClient\n\nclient = EvrmoreClient()\ninfo = client.getblockchaininfo()\nprint(f\"Block height: {info.blocks}\")\n\nasset_info = client.getassetdata(\"INFERNA\")\nprint(asset_info.amount)\n\nclient.transfer(\"INFERNA\", 10, \"EVRAddress\")\n</code></pre>"},{"location":"examples/#async-usage","title":"\ud83d\udd01 Async Usage","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreClient\n\nasync def main():\n    client = EvrmoreClient()\n    info = await client.getblockchaininfo()\n    print(\"Height:\", info['blocks'])\n    await client.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/#configuration-examples","title":"\ud83d\udd27 Configuration Examples","text":"<pre><code># From evrmore.conf\nclient = EvrmoreClient()\n\n# From env vars (EVR_RPC_*)\nclient = EvrmoreClient()\n\n# Manual override\nclient = EvrmoreClient(url=\"http://localhost:8819\", rpcuser=\"user\", rpcpassword=\"pass\")\n\n# Testnet flag\nclient = EvrmoreClient(testnet=True)\n</code></pre>"},{"location":"examples/#asset-support","title":"\ud83d\udcb0 Asset Support","text":"<pre><code>info = client.getassetdata(\"INFERNA\")\nprint(info['amount'])\n\nclient.transfer(\"INFERNA\", 10, \"EVRAddress\")\n</code></pre>"},{"location":"examples/#real-time-zmq-notifications","title":"\ud83d\udce1 Real-Time ZMQ Notifications","text":"<pre><code>from evrmore_rpc import EvrmoreClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\nrpc = EvrmoreClient()\nzmq = EvrmoreZMQClient(rpc_client=rpc)\n\n@zmq.on(ZMQTopic.BLOCK)\ndef handle_block(n):\n    print(f\"[BLOCK] #{n.height} with {len(n.block['tx'])} txs\")\n\n@zmq.on(ZMQTopic.TX)\ndef handle_tx(n):\n    print(f\"[TX] {n.tx['txid']} \u2192 {len(n.tx['vout'])} outputs\")\n\nzmq.start()\n</code></pre> <p>Supports: - <code>HASH_BLOCK</code>, <code>HASH_TX</code>, <code>RAW_BLOCK</code>, <code>RAW_TX</code> - Enhanced <code>BLOCK</code>, <code>TX</code> (auto-decoded) - Asset-aware TX parsing</p>"},{"location":"examples/#websocket-subscriptions","title":"\ud83c\udf10 WebSocket Subscriptions","text":"<pre><code>from evrmore_rpc.websockets import EvrmoreWebSocketClient\nimport asyncio\n\nasync def main():\n    client = EvrmoreWebSocketClient(uri=\"ws://localhost:8765\")\n    await client.connect()\n    await client.subscribe(\"blocks\")\n    await client.subscribe(\"transactions\")\n\n    async for message in client:\n        print(f\"{message.type}: {message.data}\")\n\nasyncio.run(main())\n</code></pre> <p>Server available via <code>EvrmoreWebSocketServer</code> with ZMQ -&gt; WS bridge built-in.</p>"},{"location":"examples/#stress-test-benchmarks","title":"\ud83d\udcca Stress Test Benchmarks","text":"<p>From <code>python3 -m evrmore_rpc.stress_test</code>, 100 calls to <code>getblockcount</code>, 10 concurrency:</p> Mode Time RPS Avg (ms) Median Min Max Local Async 0.01 s 10442.42 0.59 0.50 0.39 1.84 Local Sync 0.06 s 1861.26 1.52 1.42 0.43 3.40 Remote Async 1.75 s 57.31 167.77 155.93 111 324 Remote Sync 1.86 s 53.83 160.39 163.26 112 310"},{"location":"examples/#examples","title":"\ud83e\uddf0 Examples","text":"<pre><code>python3 -m evrmore_rpc.stress_test --sync --remote\n</code></pre> File Purpose <code>features/contextuality.py</code> Auto detect sync/async usage context <code>features/connection_pooling.py</code> Demonstrate connection reuse efficiency <code>features/complete_rpc_coverage.py</code> Validate RPC method coverage <code>features/flexible_config.py</code> Load configuration from various sources <code>features/basic_type_safety.py</code> Showcase type-safe access and results <code>features/zmq_notifications.py</code> Decoded ZMQ block/tx notifications <code>asset_operations.py</code> Asset transfers and issuance <code>basic_queries.py</code> Query blockchain data (blocks, balance, etc) <code>cookie_auth.py</code> Authentication using .cookie file <code>async_example.py</code> Async API interaction <code>test_cookie_auth.py</code> Auth unit test with .cookie <code>zmq_auto_decode.py</code> Deep decoding of tx/block via ZMQ"},{"location":"examples/#requirements","title":"\u2705 Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Evrmore daemon with RPC and optional ZMQ enabled</li> </ul>"},{"location":"examples/#license","title":"\ud83e\udeaa License","text":"<p>MIT \u2014 See LICENSE</p>"},{"location":"examples/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>PRs welcome!</p> <pre><code>git clone https://github.com/manticoretechnologies/evrmore-rpc-dev\ncd evrmore-rpc\npython3 -m venv .venv &amp;&amp; source .venv/bin/activate\npip install -e .[dev]\n</code></pre> <p>Run tests:</p> <pre><code>python3 -m evrmore_rpc.stress_test\n</code></pre>"},{"location":"examples/#summary","title":"\ud83e\udded Summary","text":"<p><code>evrmore-rpc</code> is a production-grade toolkit for Evrmore developers. Whether you're building block explorers, trading platforms, indexers, or decentralized tools, it's engineered to deliver speed, type-safety, real-time insight, and robust integration with the Evrmore chain.</p>"},{"location":"examples/#code-examples","title":"Code Examples","text":"<p>This guide provides practical examples of using the <code>evrmore-rpc</code> package for common blockchain operations.</p>"},{"location":"examples/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/#initialize-client","title":"Initialize Client","text":"<pre><code>from evrmore_rpc import EvrmoreClient\n\n# Basic initialization\nclient = EvrmoreClient()\n\n# With custom configuration\nclient = EvrmoreClient(\n    host=\"127.0.0.1\",\n    port=8332,\n    username=\"rpcuser\",\n    password=\"rpcpass\",\n    ssl=True\n)\n</code></pre>"},{"location":"examples/#get-blockchain-info","title":"Get Blockchain Info","text":"<pre><code># Get basic blockchain info\ninfo = client.getblockchaininfo()\nprint(f\"Chain: {info.chain}\")\nprint(f\"Blocks: {info.blocks}\")\nprint(f\"Headers: {info.headers}\")\nprint(f\"Best block hash: {info.bestblockhash}\")\nprint(f\"Difficulty: {info.difficulty}\")\nprint(f\"Verification progress: {info.verificationprogress}\")\n</code></pre>"},{"location":"examples/#get-block-information","title":"Get Block Information","text":"<pre><code># Get block by height\nblock = client.getblock(1000)\nprint(f\"Block hash: {block.hash}\")\nprint(f\"Previous block: {block.previousblockhash}\")\nprint(f\"Time: {block.time}\")\nprint(f\"Transactions: {len(block.tx)}\")\n\n# Get block by hash\nblock = client.getblock(\"0000000000000000000000000000000000000000000000000000000000000000\")\n</code></pre>"},{"location":"examples/#get-transaction-information","title":"Get Transaction Information","text":"<pre><code># Get transaction by ID\ntx = client.getrawtransaction(\"txid\", True)\nprint(f\"Transaction ID: {tx.txid}\")\nprint(f\"Version: {tx.version}\")\nprint(f\"Size: {tx.size}\")\nprint(f\"Inputs: {len(tx.vin)}\")\nprint(f\"Outputs: {len(tx.vout)}\")\n\n# Get transaction details\nfor vin in tx.vin:\n    print(f\"Input: {vin.txid}:{vin.vout}\")\n    print(f\"Sequence: {vin.sequence}\")\n\nfor vout in tx.vout:\n    print(f\"Output value: {vout.value}\")\n    print(f\"Script: {vout.scriptPubKey.hex}\")\n</code></pre>"},{"location":"examples/#asset-operations","title":"Asset Operations","text":""},{"location":"examples/#get-asset-information","title":"Get Asset Information","text":"<pre><code># Get asset info\nasset = client.getassetinfo(\"ASSET_NAME\")\nprint(f\"Asset name: {asset.name}\")\nprint(f\"Amount: {asset.amount}\")\nprint(f\"Units: {asset.units}\")\nprint(f\"Reissuable: {asset.reissuable}\")\nprint(f\"Has IPFS: {asset.has_ipfs}\")\nif asset.has_ipfs:\n    print(f\"IPFS hash: {asset.ipfs_hash}\")\n</code></pre>"},{"location":"examples/#transfer-assets","title":"Transfer Assets","text":"<pre><code># Create asset transfer\ntxid = client.transferasset(\n    \"ASSET_NAME\",\n    \"DESTINATION_ADDRESS\",\n    1.0,  # amount\n    \"COMMENT\",\n    \"COMMENT_TO\"\n)\nprint(f\"Transfer transaction ID: {txid}\")\n</code></pre>"},{"location":"examples/#real-time-notifications","title":"Real-Time Notifications","text":""},{"location":"examples/#zmq-notifications","title":"ZMQ Notifications","text":"<pre><code>from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\n# Initialize ZMQ client\nzmq = EvrmoreZMQClient()\n\n# Register handlers\n@zmq.on(ZMQTopic.BLOCK)\ndef handle_block(notification):\n    print(f\"New block: {notification.height}\")\n\n@zmq.on(ZMQTopic.TX)\ndef handle_tx(notification):\n    print(f\"New transaction: {notification.txid}\")\n\n# Start the client\nzmq.start()\n</code></pre>"},{"location":"examples/#websocket-notifications","title":"WebSocket Notifications","text":"<pre><code>from evrmore_rpc.websocket import EvrmoreWebSocketClient, WebSocketTopic\n\n# Initialize WebSocket client\nws = EvrmoreWebSocketClient()\n\n# Register handlers\n@ws.on(WebSocketTopic.BLOCK)\ndef handle_block(notification):\n    print(f\"New block: {notification.height}\")\n\n@ws.on(WebSocketTopic.TX)\ndef handle_tx(notification):\n    print(f\"New transaction: {notification.txid}\")\n\n# Start the client\nws.start()\n</code></pre>"},{"location":"examples/#advanced-examples","title":"Advanced Examples","text":""},{"location":"examples/#block-explorer","title":"Block Explorer","text":"<pre><code>class BlockExplorer:\n    def __init__(self):\n        self.client = EvrmoreClient()\n        self.blocks_processed = 0\n        self.transactions_processed = 0\n\n    def get_block_info(self, height):\n        block = self.client.getblock(height)\n        print(f\"\\nBlock #{height}\")\n        print(f\"Hash: {block.hash}\")\n        print(f\"Time: {block.time}\")\n        print(f\"Size: {block.size} bytes\")\n        print(f\"Transactions: {len(block.tx)}\")\n\n        # Get transaction details\n        for txid in block.tx:\n            tx = self.client.getrawtransaction(txid, True)\n            print(f\"\\nTransaction: {txid}\")\n            print(f\"Size: {tx.size} bytes\")\n            print(f\"Inputs: {len(tx.vin)}\")\n            print(f\"Outputs: {len(tx.vout)}\")\n\n            # Check for asset transfers\n            for vout in tx.vout:\n                if \"asset\" in vout.get(\"scriptPubKey\", {}).get(\"asset\", {}):\n                    asset = vout[\"scriptPubKey\"][\"asset\"]\n                    print(f\"Asset transfer: {asset['name']} ({asset['amount']})\")\n</code></pre>"},{"location":"examples/#asset-tracker","title":"Asset Tracker","text":"<pre><code>class AssetTracker:\n    def __init__(self):\n        self.client = EvrmoreClient()\n        self.assets = {}\n\n    def track_asset(self, asset_name):\n        # Get asset info\n        asset = self.client.getassetinfo(asset_name)\n        self.assets[asset_name] = {\n            \"name\": asset.name,\n            \"amount\": asset.amount,\n            \"units\": asset.units,\n            \"reissuable\": asset.reissuable,\n            \"transfers\": []\n        }\n\n    def get_asset_transfers(self, asset_name, start_block=0):\n        if asset_name not in self.assets:\n            self.track_asset(asset_name)\n\n        current_height = self.client.getblockcount()\n\n        for height in range(start_block, current_height + 1):\n            block = self.client.getblock(height)\n\n            for txid in block.tx:\n                tx = self.client.getrawtransaction(txid, True)\n\n                for vout in tx.vout:\n                    if \"asset\" in vout.get(\"scriptPubKey\", {}).get(\"asset\", {}):\n                        asset = vout[\"scriptPubKey\"][\"asset\"]\n                        if asset[\"name\"] == asset_name:\n                            self.assets[asset_name][\"transfers\"].append({\n                                \"txid\": txid,\n                                \"amount\": asset[\"amount\"],\n                                \"block\": height,\n                                \"time\": block.time\n                            })\n</code></pre>"},{"location":"examples/#transaction-monitor","title":"Transaction Monitor","text":"<pre><code>class TransactionMonitor:\n    def __init__(self):\n        self.client = EvrmoreClient()\n        self.watched_addresses = set()\n        self.transactions = {}\n\n    def watch_address(self, address):\n        self.watched_addresses.add(address)\n\n    def get_address_transactions(self, address):\n        if address not in self.watched_addresses:\n            self.watch_address(address)\n\n        # Get all transactions for address\n        txs = self.client.getaddresstxids({\"addresses\": [address]})\n\n        for txid in txs:\n            if txid not in self.transactions:\n                tx = self.client.getrawtransaction(txid, True)\n                self.transactions[txid] = {\n                    \"txid\": txid,\n                    \"time\": tx.time,\n                    \"inputs\": [],\n                    \"outputs\": []\n                }\n\n                # Process inputs\n                for vin in tx.vin:\n                    if \"coinbase\" not in vin:\n                        prev_tx = self.client.getrawtransaction(vin.txid, True)\n                        prev_vout = prev_tx.vout[vin.vout]\n                        self.transactions[txid][\"inputs\"].append({\n                            \"address\": prev_vout.scriptPubKey.addresses[0],\n                            \"amount\": prev_vout.value\n                        })\n\n                # Process outputs\n                for vout in tx.vout:\n                    if \"addresses\" in vout.scriptPubKey:\n                        self.transactions[txid][\"outputs\"].append({\n                            \"address\": vout.scriptPubKey.addresses[0],\n                            \"amount\": vout.value\n                        })\n</code></pre>"},{"location":"examples/#error-handling","title":"Error Handling","text":"<pre><code>from evrmore_rpc import EvrmoreRPCError\n\ntry:\n    # Make RPC call\n    result = client.getblockchaininfo()\nexcept EvrmoreRPCError as e:\n    print(f\"RPC error: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"examples/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Use connection pooling\nfrom evrmore_rpc import EvrmoreClient, ConnectionPool\n\n# Create connection pool\npool = ConnectionPool(\n    host=\"127.0.0.1\",\n    port=8332,\n    username=\"rpcuser\",\n    password=\"rpcpass\",\n    max_connections=10\n)\n\n# Get client from pool\nclient = pool.get_client()\n\n# Use client\nresult = client.getblockchaininfo()\n\n# Return client to pool\npool.return_client(client)\n\n# Batch process blocks\ndef process_blocks(start_height, end_height):\n    for height in range(start_height, end_height + 1):\n        block = client.getblock(height)\n        # Process block data\n</code></pre>"},{"location":"examples/#see-also","title":"See Also","text":"<ul> <li>Getting Started for basic usage</li> <li>API Reference for detailed API docs</li> <li>ZMQ Guide for real-time notifications</li> <li>WebSocket Guide for WebSocket integration</li> <li>Advanced Usage for production patterns</li> </ul>"},{"location":"getting-started/","title":"Getting Started with evrmore-rpc","text":"<p>This guide will help you get started with the <code>evrmore-rpc</code> Python client for the Evrmore blockchain.</p>"},{"location":"getting-started/#installation","title":"\ud83d\udce6 Installation","text":"<p>Install the package using pip:</p> <pre><code>pip install evrmore-rpc\n</code></pre> <p>Optional extras:</p> <pre><code>pip install evrmore-rpc[websockets]     # For WebSocket support\npip install evrmore-rpc[full]           # All optional dependencies\n</code></pre>"},{"location":"getting-started/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<pre><code>from evrmore_rpc import EvrmoreClient\n\n# Create a client (auto-loads from evrmore.conf)\nclient = EvrmoreClient()\n\n# Get blockchain info\ninfo = client.getblockchaininfo()\nprint(f\"Current block height: {info['blocks']}\")\nprint(f\"Chain: {info['chain']}\")\nprint(f\"Difficulty: {info['difficulty']}\")\n\n# Get a specific block\nblock_hash = client.getblockhash(1)\nblock = client.getblock(block_hash)\nprint(f\"Block #1 hash: {block.hash}\")\nprint(f\"Block #1 time: {block.time}\")\nprint(f\"Block #1 transactions: {len(block.tx)}\")\n</code></pre>"},{"location":"getting-started/#asynchronous-usage","title":"Asynchronous Usage","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreClient\n\nasync def main():\n    # Create client\n    client = EvrmoreClient()\n\n    # Get blockchain info\n    info = await client.getblockchaininfo()\n    print(f\"Current block height: {info['blocks']}\")\n\n    # Get a block\n    block_hash = await client.getblockhash(1)\n    block = await client.getblock(block_hash)\n    print(f\"Block #1 hash: {block.hash}\")\n\n    # Close the client\n    await client.close()\n\n# Run the async code\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/#configuration","title":"\u2699\ufe0f Configuration","text":"<p>The client can be configured in several ways:</p>"},{"location":"getting-started/#1-using-evrmoreconf","title":"1. Using evrmore.conf","text":"<p>By default, the client will look for <code>evrmore.conf</code> in the default Evrmore data directory:</p> <pre><code>client = EvrmoreClient()  # Auto-loads from evrmore.conf\n</code></pre>"},{"location":"getting-started/#2-environment-variables","title":"2. Environment Variables","text":"<p>Set these environment variables to configure the client:</p> <pre><code>EVR_RPC_URL=http://localhost:8819\nEVR_RPC_USER=user\nEVR_RPC_PASSWORD=pass\nEVR_RPC_PORT=8819\nEVR_TESTNET=true\n</code></pre> <p>Then create the client:</p> <pre><code>client = EvrmoreClient()  # Auto-loads from environment\n</code></pre>"},{"location":"getting-started/#3-manual-configuration","title":"3. Manual Configuration","text":"<pre><code>client = EvrmoreClient(\n    url=\"http://localhost:8819\",\n    rpcuser=\"user\",\n    rpcpassword=\"pass\",\n    rpcport=8819,\n    testnet=True,\n    timeout=30,\n    async_mode=None  # Auto-detect or force sync/async\n)\n</code></pre>"},{"location":"getting-started/#4-cookie-authentication","title":"4. Cookie Authentication","text":"<p>The client can automatically read from the <code>.cookie</code> file:</p> <pre><code>client = EvrmoreClient(datadir=\"~/.evrmore\")\n</code></pre>"},{"location":"getting-started/#asset-support","title":"\ud83d\udcb0 Asset Support","text":"<pre><code># Get asset info\ninfo = client.getassetdata(\"MYTOKEN\")\nprint(f\"Amount: {info['amount']}\")\nprint(f\"Reissuable: {info['reissuable']}\")\n\n# Transfer asset\ntxid = client.transfer(\"MYTOKEN\", 100, \"EVRAddress\")\nprint(f\"Transfer txid: {txid}\")\n</code></pre>"},{"location":"getting-started/#real-time-notifications","title":"\ud83d\udce1 Real-Time Notifications","text":"<p>For real-time blockchain notifications, see the ZMQ Guide and WebSocket Guide.</p>"},{"location":"getting-started/#next-steps","title":"\ud83d\udd0d Next Steps","text":"<ul> <li>Check out the API Reference for detailed method documentation</li> <li>Explore Examples for more usage patterns</li> <li>Read Advanced Usage for production best practices</li> <li>Learn about Development if you want to contribute </li> </ul>"},{"location":"models/","title":"evrmore-rpc: Python Client for Evrmore Blockchain","text":"<p>A high-performance, full-featured Python client for the Evrmore blockchain. Designed for real-world applications like wallets, explorers, and exchanges, it includes synchronous and asynchronous RPC support, auto-decoding ZMQ streams, typed WebSocket communication, structured data models, and powerful developer tools.</p>"},{"location":"models/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>\ud83d\udd04 Context-Aware: Auto-adapts between sync and async execution</li> <li>\u2699\ufe0f Flexible Config: Load from <code>evrmore.conf</code>, environment, or arguments</li> <li>\ud83d\udd10 Cookie &amp; Auth: Supports <code>.cookie</code> file and manual RPC credentials</li> <li>\ud83d\udca1 Typed RPC Coverage: All RPC methods typed with Pydantic models</li> <li>\u26a1 Connection Pooling: Fast RPC calls with keep-alive sessions</li> <li>\ud83e\udde0 Asset Intelligence: Decodes asset transactions, supply, metadata</li> <li>\ud83d\udce1 ZMQ Real-Time Streams: HASH_, RAW_, BLOCK, TX w/ decoding</li> <li>\ud83c\udf10 WebSocket Support: Realtime server and client push subscriptions</li> <li>\ud83d\udcca CLI &amp; Stress Tools: Benchmark, test, and audit performance</li> <li>\ud83e\uddea Extensive Examples: From zero to production-ready integrations</li> </ul>"},{"location":"models/#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip install evrmore-rpc\n</code></pre> <p>Optional extras:</p> <pre><code>pip install evrmore-rpc[websockets]     # For WebSocket support\npip install evrmore-rpc[full]           # All optional dependencies\n</code></pre>"},{"location":"models/#quick-start","title":"\ud83e\uddea Quick Start","text":"<pre><code>from evrmore_rpc import EvrmoreClient\n\nclient = EvrmoreClient()\ninfo = client.getblockchaininfo()\nprint(\"Height:\", info['blocks'])\n</code></pre>"},{"location":"models/#synchronous-api-example","title":"\ud83e\udded Synchronous API Example","text":"<pre><code>from evrmore_rpc import EvrmoreClient\n\nclient = EvrmoreClient()\ninfo = client.getblockchaininfo()\nprint(f\"Block height: {info.blocks}\")\n\nasset_info = client.getassetdata(\"INFERNA\")\nprint(asset_info.amount)\n\nclient.transfer(\"INFERNA\", 10, \"EVRAddress\")\n</code></pre>"},{"location":"models/#async-usage","title":"\ud83d\udd01 Async Usage","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreClient\n\nasync def main():\n    client = EvrmoreClient()\n    info = await client.getblockchaininfo()\n    print(\"Height:\", info['blocks'])\n    await client.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"models/#configuration-examples","title":"\ud83d\udd27 Configuration Examples","text":"<pre><code># From evrmore.conf\nclient = EvrmoreClient()\n\n# From env vars (EVR_RPC_*)\nclient = EvrmoreClient()\n\n# Manual override\nclient = EvrmoreClient(url=\"http://localhost:8819\", rpcuser=\"user\", rpcpassword=\"pass\")\n\n# Testnet flag\nclient = EvrmoreClient(testnet=True)\n</code></pre>"},{"location":"models/#asset-support","title":"\ud83d\udcb0 Asset Support","text":"<pre><code>info = client.getassetdata(\"INFERNA\")\nprint(info['amount'])\n\nclient.transfer(\"INFERNA\", 10, \"EVRAddress\")\n</code></pre>"},{"location":"models/#real-time-zmq-notifications","title":"\ud83d\udce1 Real-Time ZMQ Notifications","text":"<pre><code>from evrmore_rpc import EvrmoreClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\nrpc = EvrmoreClient()\nzmq = EvrmoreZMQClient(rpc_client=rpc)\n\n@zmq.on(ZMQTopic.BLOCK)\ndef handle_block(n):\n    print(f\"[BLOCK] #{n.height} with {len(n.block['tx'])} txs\")\n\n@zmq.on(ZMQTopic.TX)\ndef handle_tx(n):\n    print(f\"[TX] {n.tx['txid']} \u2192 {len(n.tx['vout'])} outputs\")\n\nzmq.start()\n</code></pre> <p>Supports: - <code>HASH_BLOCK</code>, <code>HASH_TX</code>, <code>RAW_BLOCK</code>, <code>RAW_TX</code> - Enhanced <code>BLOCK</code>, <code>TX</code> (auto-decoded) - Asset-aware TX parsing</p>"},{"location":"models/#websocket-subscriptions","title":"\ud83c\udf10 WebSocket Subscriptions","text":"<pre><code>from evrmore_rpc.websockets import EvrmoreWebSocketClient\nimport asyncio\n\nasync def main():\n    client = EvrmoreWebSocketClient(uri=\"ws://localhost:8765\")\n    await client.connect()\n    await client.subscribe(\"blocks\")\n    await client.subscribe(\"transactions\")\n\n    async for message in client:\n        print(f\"{message.type}: {message.data}\")\n\nasyncio.run(main())\n</code></pre> <p>Server available via <code>EvrmoreWebSocketServer</code> with ZMQ -&gt; WS bridge built-in.</p>"},{"location":"models/#stress-test-benchmarks","title":"\ud83d\udcca Stress Test Benchmarks","text":"<p>From <code>python3 -m evrmore_rpc.stress_test</code>, 100 calls to <code>getblockcount</code>, 10 concurrency:</p> Mode Time RPS Avg (ms) Median Min Max Local Async 0.01 s 10442.42 0.59 0.50 0.39 1.84 Local Sync 0.06 s 1861.26 1.52 1.42 0.43 3.40 Remote Async 1.75 s 57.31 167.77 155.93 111 324 Remote Sync 1.86 s 53.83 160.39 163.26 112 310"},{"location":"models/#examples","title":"\ud83e\uddf0 Examples","text":"<pre><code>python3 -m evrmore_rpc.stress_test --sync --remote\n</code></pre> File Purpose <code>readme_test.py</code> Basic synchronous and async usage demo <code>stress_test.py</code> Performance benchmark w/ metrics <code>connection_pooling.py</code> Show pooling vs no-pooling RPC comparisons <code>flexible_config.py</code> Load settings from multiple sources <code>rpc_coverage.py</code> Validate RPC method coverage + docs <code>zmq_notifications.py</code> Listen to real-time decoded blockchain txs"},{"location":"models/#requirements","title":"\u2705 Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Evrmore daemon with RPC and optional ZMQ enabled</li> </ul>"},{"location":"models/#license","title":"\ud83e\udeaa License","text":"<p>MIT \u2014 See LICENSE</p>"},{"location":"models/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>PRs welcome!</p> <pre><code>git clone https://github.com/manticoretechnologies/evrmore-rpc-dev\ncd evrmore-rpc\npython3 -m venv .venv &amp;&amp; source .venv/bin/activate\npip install -e .[dev]\n</code></pre> <p>Run tests:</p> <pre><code>python3 -m evrmore_rpc.stress_test\n</code></pre>"},{"location":"models/#summary","title":"\ud83e\udded Summary","text":"<p><code>evrmore-rpc</code> is a production-grade toolkit for Evrmore developers. Whether you're building block explorers, trading platforms, indexers, or decentralized tools, it's engineered to deliver speed, type-safety, real-time insight, and robust integration with the Evrmore chain.</p>"},{"location":"websockets/","title":"evrmore-rpc: Python Client for Evrmore Blockchain","text":"<p>A high-performance, full-featured Python client for the Evrmore blockchain. Designed for real-world applications like wallets, explorers, and exchanges, it includes synchronous and asynchronous RPC support, auto-decoding ZMQ streams, rich asset tracking, and powerful dev tools.</p>"},{"location":"websockets/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>\ud83d\udd04 Context-Aware: Auto-adapts between sync and async execution</li> <li>\u2699\ufe0f Flexible Config: Load from <code>evrmore.conf</code>, environment, or args</li> <li>\ud83d\udd10 Cookie &amp; Auth: Supports <code>.cookie</code> file and manual RPC credentials</li> <li>\ud83d\udca1 Complete RPC Coverage: All RPC methods typed and structured</li> <li>\u26a1 Connection Pooling: Blazing fast requests with reuse support</li> <li>\ud83e\udde0 Asset Intelligence: Detects and decodes asset transactions with extras</li> <li>\ud83d\udce1 ZMQ Real-Time Streams: Receive HASH_, RAW_, BLOCK, TX</li> <li>\ud83e\uddea Fully Tested Tools: Built-in stress test, coverage audit, flexible demos</li> </ul>"},{"location":"websockets/#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip install evrmore-rpc\n</code></pre>"},{"location":"websockets/#quick-start","title":"\ud83e\uddea Quick Start","text":"<pre><code>from evrmore_rpc import EvrmoreClient\n\nclient = EvrmoreClient()\ninfo = client.getblockchaininfo()\nprint(\"Height:\", info['blocks'])\n</code></pre>"},{"location":"websockets/#async-usage","title":"\ud83d\udd01 Async Usage","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreClient\n\nasync def main():\n    client = EvrmoreClient()\n    info = await client.getblockchaininfo()\n    print(\"Height:\", info['blocks'])\n    await client.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"websockets/#configuration-examples","title":"\ud83d\udd27 Configuration Examples","text":"<pre><code># From evrmore.conf\nclient = EvrmoreClient()\n\n# From env vars (EVR_RPC_*)\nclient = EvrmoreClient()\n\n# Manual override\nclient = EvrmoreClient(url=\"http://localhost:8819\", rpcuser=\"user\", rpcpassword=\"pass\")\n\n# Testnet flag\nclient = EvrmoreClient(testnet=True)\n</code></pre>"},{"location":"websockets/#asset-support","title":"\ud83d\udcb0 Asset Support","text":"<pre><code>info = client.getassetdata(\"INFERNA\")\nprint(info['amount'])\n\nclient.transfer(\"INFERNA\", 10, \"EVRAddress\")\n</code></pre>"},{"location":"websockets/#real-time-zmq-notifications","title":"\ud83d\udce1 Real-Time ZMQ Notifications","text":"<pre><code>from evrmore_rpc import EvrmoreClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\nrpc = EvrmoreClient()\nzmq = EvrmoreZMQClient(rpc_client=rpc)\n\n@zmq.on(ZMQTopic.BLOCK)\ndef handle_block(n):\n    print(f\"[BLOCK] #{n.height} with {len(n.block['tx'])} txs\")\n\n@zmq.on(ZMQTopic.TX)\ndef handle_tx(n):\n    print(f\"[TX] {n.tx['txid']} \u2192 {len(n.tx['vout'])} outputs\")\n\nzmq.start()\n</code></pre> <p>Supports: - <code>HASH_BLOCK</code>, <code>HASH_TX</code>, <code>RAW_BLOCK</code>, <code>RAW_TX</code> - Enhanced <code>BLOCK</code>, <code>TX</code> (auto-decoded) - Asset-aware TX parsing</p>"},{"location":"websockets/#stress-test-benchmarks","title":"\ud83d\udcca Stress Test Benchmarks","text":"<p>From <code>python3 -m evrmore_rpc.stress_test</code>, 100 calls to <code>getblockcount</code>, 10 concurrency:</p> Mode Time RPS Avg (ms) Median Min Max Local Async 0.01 s 10442.42 0.59 0.50 0.39 1.84 Local Sync 0.06 s 1861.26 1.52 1.42 0.43 3.40 Remote Async 1.75 s 57.31 167.77 155.93 111 324 Remote Sync 1.86 s 53.83 160.39 163.26 112 310"},{"location":"websockets/#examples","title":"\ud83e\uddf0 Examples","text":"<pre><code>python3 -m evrmore_rpc.stress_test --sync --remote\n</code></pre> File Purpose <code>readme_test.py</code> Basic synchronous and async usage demo <code>stress_test.py</code> Performance benchmark w/ metrics <code>connection_pooling.py</code> Show pooling vs no-pooling RPC comparisons <code>flexible_config.py</code> Load settings from multiple sources <code>rpc_coverage.py</code> Validate RPC method coverage + docs <code>zmq_notifications.py</code> Listen to real-time decoded blockchain txs"},{"location":"websockets/#requirements","title":"\u2705 Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Evrmore daemon with RPC and optional ZMQ enabled</li> </ul>"},{"location":"websockets/#license","title":"\ud83e\udeaa License","text":"<p>MIT \u2014 See LICENSE</p>"},{"location":"websockets/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>PRs welcome!</p> <pre><code>git clone https://github.com/manticoretechnologies/evrmore-rpc-dev\ncd evrmore-rpc\npython3 -m venv .venv &amp;&amp; source .venv/bin/activate\npip install -e .[dev]\n</code></pre> <p>Run tests:</p> <pre><code>python3 -m evrmore_rpc.stress_test\n</code></pre>"},{"location":"websockets/#summary","title":"\ud83e\udded Summary","text":"<p><code>evrmore-rpc</code> is a production-grade toolkit for Evrmore developers. Whether you're building block explorers, trading platforms, or indexers, it's engineered to deliver speed, reliability, and seamless integration with the Evrmore chain.</p>"},{"location":"websockets/#websocket-integration-guide","title":"WebSocket Integration Guide","text":"<p>This guide covers how to use WebSocket notifications with the <code>evrmore-rpc</code> package to receive real-time blockchain updates.</p>"},{"location":"websockets/#overview","title":"Overview","text":"<p>The <code>EvrmoreWebSocketClient</code> provides a modern interface for receiving real-time blockchain notifications via WebSocket. It supports:</p> <ul> <li>Automatic context detection (sync/async)</li> <li>Enhanced asset metadata in decoded transactions</li> <li>Automatic reconnection on connection loss</li> <li>Clean shutdown and resource management</li> <li>Typed notification data with structured fields</li> </ul>"},{"location":"websockets/#configuration","title":"Configuration","text":""},{"location":"websockets/#required-evrmoreconf-settings","title":"Required evrmore.conf Settings","text":"<p>Add these lines to your <code>evrmore.conf</code>:</p> <pre><code>server=1\nrpcallowip=127.0.0.1\nrpcbind=127.0.0.1\n</code></pre>"},{"location":"websockets/#client-setup","title":"Client Setup","text":"<pre><code>from evrmore_rpc import EvrmoreClient\nfrom evrmore_rpc.websocket import EvrmoreWebSocketClient, WebSocketTopic\n\n# Create RPC client for auto-decoding\nrpc = EvrmoreClient()\n\n# Create WebSocket client\nws = EvrmoreWebSocketClient(\n    ws_host=\"127.0.0.1\",\n    ws_port=8332,\n    topics=[WebSocketTopic.BLOCK, WebSocketTopic.TX],\n    rpc_client=rpc,\n    auto_decode=True\n)\n</code></pre>"},{"location":"websockets/#available-topics","title":"Available Topics","text":"Topic Description Requires RPC <code>BLOCK</code> Block notifications Yes <code>TX</code> Transaction notifications Yes <code>ASSET</code> Asset notifications Yes <code>ADDRESS</code> Address notifications Yes"},{"location":"websockets/#event-handlers","title":"Event Handlers","text":""},{"location":"websockets/#block-notifications","title":"Block Notifications","text":"<pre><code>@ws.on(WebSocketTopic.BLOCK)\ndef handle_block(notification):\n    print(f\"Block #{notification.height}\")\n    print(f\"Hash: {notification.hash}\")\n    print(f\"Transactions: {len(notification.tx)}\")\n\n    # Access block data\n    block = notification.block\n    print(f\"Size: {block.get('size', 'N/A')} bytes\")\n    print(f\"Time: {block.get('time', 'N/A')}\")\n    print(f\"Difficulty: {block.get('difficulty', 'N/A')}\")\n</code></pre>"},{"location":"websockets/#transaction-notifications","title":"Transaction Notifications","text":"<pre><code>@ws.on(WebSocketTopic.TX)\ndef handle_tx(notification):\n    print(f\"TX {notification.txid}\")\n    print(f\"Size: {notification.size} bytes\")\n    print(f\"Version: {notification.version}\")\n\n    # Check for asset data\n    if notification.has_assets:\n        print(\"\\nAsset Information:\")\n        for asset in notification.asset_info:\n            print(f\"Asset: {asset.name}\")\n            print(f\"Amount: {asset.amount}\")\n            print(f\"Type: {asset.type}\")\n</code></pre>"},{"location":"websockets/#usage-examples","title":"Usage Examples","text":""},{"location":"websockets/#synchronous-usage","title":"Synchronous Usage","text":"<pre><code>import signal\nimport sys\nfrom evrmore_rpc.websocket import EvrmoreWebSocketClient, WebSocketTopic\n\n# Initialize client\nws = EvrmoreWebSocketClient()\n\n# Handle Ctrl+C\ndef signal_handler(sig, frame):\n    print(\"\\nShutting down...\")\n    ws.stop()\n    sys.exit(0)\n\nsignal.signal(signal.SIGINT, signal_handler)\n\n# Register handlers\n@ws.on(WebSocketTopic.BLOCK)\ndef handle_block(notification):\n    print(f\"Block #{notification.height}\")\n\n@ws.on(WebSocketTopic.TX)\ndef handle_tx(notification):\n    print(f\"TX {notification.txid}\")\n\n# Start the client\nws.start()\n\n# Keep running\nwhile True:\n    import time\n    time.sleep(1)\n</code></pre>"},{"location":"websockets/#asynchronous-usage","title":"Asynchronous Usage","text":"<pre><code>import asyncio\nfrom evrmore_rpc.websocket import EvrmoreWebSocketClient, WebSocketTopic\n\nasync def main():\n    # Initialize client\n    ws = EvrmoreWebSocketClient()\n\n    # Register handlers\n    @ws.on(WebSocketTopic.BLOCK)\n    async def handle_block(notification):\n        print(f\"Block #{notification.height}\")\n\n    @ws.on(WebSocketTopic.TX)\n    async def handle_tx(notification):\n        print(f\"TX {notification.txid}\")\n\n    # Start the client\n    await ws.start()\n\n    try:\n        # Keep running\n        while True:\n            await asyncio.sleep(1)\n    except KeyboardInterrupt:\n        print(\"\\nShutting down...\")\n    finally:\n        await ws.stop()\n\nasyncio.run(main())\n</code></pre>"},{"location":"websockets/#advanced-features","title":"Advanced Features","text":""},{"location":"websockets/#custom-message-processing","title":"Custom Message Processing","text":"<pre><code>class BlockchainMonitor:\n    def __init__(self):\n        self.ws_client = EvrmoreWebSocketClient()\n        self.rpc_client = EvrmoreClient()\n        self.blocks_processed = 0\n        self.transactions_processed = 0\n        self.asset_transfers = []\n\n    async def start(self):\n        # Register handlers\n        self.ws_client.on_block(self.handle_block)\n        self.ws_client.on_transaction(self.handle_transaction)\n\n        # Start the WebSocket client\n        await self.ws_client.start()\n        print(\"Blockchain monitor started\")\n\n    async def stop(self):\n        await self.ws_client.stop()\n        print(\"Blockchain monitor stopped\")\n\n    async def handle_block(self, notification):\n        block_hash = notification.hash\n        block = self.rpc_client.getblock(block_hash)\n\n        self.blocks_processed += 1\n        print(f\"New block: {block.hash} (height: {block.height})\")\n        print(f\"Block contains {len(block.tx)} transactions\")\n\n        # Analyze block data\n        if len(block.tx) &gt; 100:\n            print(f\"Large block detected: {len(block.tx)} transactions\")\n\n    async def handle_transaction(self, notification):\n        txid = notification.txid\n\n        try:\n            tx = self.rpc_client.getrawtransaction(txid, True)\n            self.transactions_processed += 1\n\n            # Check for asset transfers\n            for vout in tx.vout:\n                if \"asset\" in vout.get(\"scriptPubKey\", {}).get(\"asset\", {}):\n                    asset = vout[\"scriptPubKey\"][\"asset\"]\n                    print(f\"Asset transfer detected: {asset['name']} ({asset['amount']})\")\n\n                    self.asset_transfers.append({\n                        \"txid\": txid,\n                        \"asset\": asset[\"name\"],\n                        \"amount\": asset[\"amount\"],\n                        \"time\": tx.time if hasattr(tx, \"time\") else None\n                    })\n        except Exception as e:\n            print(f\"Error processing transaction {txid}: {e}\")\n</code></pre>"},{"location":"websockets/#error-handling","title":"Error Handling","text":"<pre><code>from evrmore_rpc.websocket import EvrmoreWebSocketError\n\ntry:\n    ws.start()\nexcept EvrmoreWebSocketError as e:\n    print(f\"WebSocket error: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"websockets/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Use appropriate reconnection settings</li> <li>Set appropriate cleanup timeouts</li> <li>Consider using async mode for better performance</li> <li>Monitor memory usage with large transaction volumes</li> <li>Use connection pooling for multiple clients</li> </ul>"},{"location":"websockets/#see-also","title":"See Also","text":"<ul> <li>Getting Started for basic usage</li> <li>API Reference for detailed API docs</li> <li>Examples for more code samples</li> <li>Advanced Usage for production patterns</li> </ul>"},{"location":"zmq/","title":"evrmore-rpc: Python Client for Evrmore Blockchain","text":"<p>A high-performance, fully featured Python client for the Evrmore blockchain. Designed for both synchronous and asynchronous environments, it includes full RPC and ZMQ support, automatic decoding of blocks and transactions, intelligent asset detection, and robust configuration options.</p>"},{"location":"zmq/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>\ud83d\udd04 Context-Aware: Automatically switches between sync and async modes</li> <li>\u2699\ufe0f Flexible Configuration: Load settings from <code>evrmore.conf</code>, env vars, or manual args</li> <li>\ud83d\udca1 Smart RPC Handling: Full method coverage with type hints and structured responses</li> <li>\u26a1 Fast + Efficient: Connection pooling for low-latency concurrent RPC calls</li> <li>\ud83e\udde0 Asset Intelligence: Auto-parses asset transactions with enhanced metadata</li> <li>\ud83d\udce1 ZMQ Notifications: Real-time support for BLOCK, TX, HASH_, RAW_, and asset events</li> <li>\ud83e\uddf0 Fully Tested Utilities: Includes stress test, coverage audit, pooling demo, and more</li> </ul>"},{"location":"zmq/#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip install evrmore-rpc\n</code></pre>"},{"location":"zmq/#quick-start","title":"\ud83e\uddea Quick Start","text":"<pre><code>from evrmore_rpc import EvrmoreClient\n\nclient = EvrmoreClient()\ninfo = client.getblockchaininfo()\nprint(\"Height:\", info['blocks'])\nprint(\"Difficulty:\", info['difficulty'])\n</code></pre>"},{"location":"zmq/#asynchronous-usage","title":"\ud83d\udd01 Asynchronous Usage","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreClient\n\nasync def main():\n    client = EvrmoreClient()\n    info = await client.getblockchaininfo()\n    print(\"Height:\", info['blocks'])\n    await client.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"zmq/#configuration-options","title":"\ud83e\udde9 Configuration Options","text":"<pre><code># Default (evrmore.conf)\nclient = EvrmoreClient()\n\n# Env vars (EVR_RPC_*)\nclient = EvrmoreClient()\n\n# Manual args\nclient = EvrmoreClient(url=\"http://localhost:8819\", rpcuser=\"user\", rpcpassword=\"pass\")\n\n# Testnet toggle\nclient = EvrmoreClient(testnet=True)\n</code></pre> <p>Supports cookie authentication and auto-parsing of <code>.cookie</code> file.</p>"},{"location":"zmq/#asset-support","title":"\ud83d\udcb0 Asset Support","text":"<pre><code># Get asset info\ninfo = client.getassetdata(\"MYTOKEN\")\nprint(info['amount'], info['reissuable'])\n\n# Transfer asset\ntxid = client.transfer(\"MYTOKEN\", 100, \"EVRAddress\")\n</code></pre>"},{"location":"zmq/#zmq-notifications-real-time","title":"\ud83d\udce1 ZMQ Notifications (Real-Time)","text":""},{"location":"zmq/#zmq-notifications-guide","title":"ZMQ Notifications Guide","text":"<p>This guide covers how to use ZeroMQ (ZMQ) notifications with the <code>evrmore-rpc</code> package to receive real-time blockchain updates.</p>"},{"location":"zmq/#overview","title":"Overview","text":"<p>The <code>EvrmoreZMQClient</code> provides a seamless interface for receiving real-time blockchain notifications via ZeroMQ. It supports:</p> <ul> <li>Automatic context detection (sync/async)</li> <li>Enhanced asset metadata in decoded transactions</li> <li>Automatic reconnection on connection loss</li> <li>Clean shutdown and resource management</li> <li>Typed notification data with structured fields</li> </ul>"},{"location":"zmq/#configuration","title":"Configuration","text":""},{"location":"zmq/#required-evrmoreconf-settings","title":"Required evrmore.conf Settings","text":"<p>Add these lines to your <code>evrmore.conf</code>:</p> <pre><code>zmqpubhashblock=tcp://127.0.0.1:28332\nzmqpubhashtx=tcp://127.0.0.1:28332\nzmqpubrawblock=tcp://127.0.0.1:28332\nzmqpubrawtx=tcp://127.0.0.1:28332\n</code></pre>"},{"location":"zmq/#client-setup","title":"Client Setup","text":"<pre><code>from evrmore_rpc import EvrmoreClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\n# Create RPC client for auto-decoding\nrpc = EvrmoreClient()\n\n# Create ZMQ client\nzmq = EvrmoreZMQClient(\n    zmq_host=\"127.0.0.1\",\n    zmq_port=28332,\n    topics=[ZMQTopic.BLOCK, ZMQTopic.TX],\n    rpc_client=rpc,\n    auto_decode=True\n)\n</code></pre>"},{"location":"zmq/#available-topics","title":"Available Topics","text":"Topic Description Requires RPC <code>HASH_BLOCK</code> Block hash notifications No <code>HASH_TX</code> Transaction hash notifications No <code>RAW_BLOCK</code> Raw serialized block data No <code>RAW_TX</code> Raw serialized transaction data No <code>BLOCK</code> Auto-decoded block data Yes <code>TX</code> Auto-decoded transaction data Yes"},{"location":"zmq/#event-handlers","title":"Event Handlers","text":""},{"location":"zmq/#block-notifications","title":"Block Notifications","text":"<pre><code>@zmq.on(ZMQTopic.BLOCK)\ndef handle_block(notification):\n    print(f\"Block #{notification.height}\")\n    print(f\"Hash: {notification.hex}\")\n    print(f\"Transactions: {len(notification.block['tx'])}\")\n\n    # Access block data\n    block = notification.block\n    print(f\"Size: {block.get('size', 'N/A')} bytes\")\n    print(f\"Time: {block.get('time', 'N/A')}\")\n    print(f\"Difficulty: {block.get('difficulty', 'N/A')}\")\n</code></pre>"},{"location":"zmq/#transaction-notifications","title":"Transaction Notifications","text":"<pre><code>@zmq.on(ZMQTopic.TX)\ndef handle_tx(notification):\n    print(f\"TX {notification.tx['txid']}\")\n    print(f\"Size: {notification.tx.get('size', 'N/A')} bytes\")\n    print(f\"Version: {notification.tx.get('version', 'N/A')}\")\n\n    # Check for asset data\n    if notification.has_assets:\n        print(\"\\nAsset Information:\")\n        for asset in notification.asset_info:\n            print(f\"Asset: {asset.get('name', 'N/A')}\")\n            print(f\"Amount: {asset.get('amount', 'N/A')}\")\n            print(f\"Type: {asset.get('type', 'N/A')}\")\n</code></pre>"},{"location":"zmq/#usage-examples","title":"Usage Examples","text":""},{"location":"zmq/#synchronous-usage","title":"Synchronous Usage","text":"<pre><code>import signal\nimport sys\nfrom evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\n# Initialize client\nzmq = EvrmoreZMQClient()\nzmq.set_lingering(0)  # For fast shutdown\n\n# Handle Ctrl+C\ndef signal_handler(sig, frame):\n    print(\"\\nShutting down...\")\n    zmq.stop()\n    sys.exit(0)\n\nsignal.signal(signal.SIGINT, signal_handler)\n\n# Register handlers\n@zmq.on(ZMQTopic.BLOCK)\ndef handle_block(notification):\n    print(f\"Block #{notification.height}\")\n\n@zmq.on(ZMQTopic.TX)\ndef handle_tx(notification):\n    print(f\"TX {notification.tx['txid']}\")\n\n# Start the client\nzmq.start()\n\n# Keep running\nwhile True:\n    import time\n    time.sleep(1)\n</code></pre>"},{"location":"zmq/#asynchronous-usage_1","title":"Asynchronous Usage","text":"<pre><code>import asyncio\nfrom evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\nasync def main():\n    # Initialize client\n    zmq = EvrmoreZMQClient()\n    zmq.set_lingering(0)\n\n    # Register handlers\n    @zmq.on(ZMQTopic.BLOCK)\n    async def handle_block(notification):\n        print(f\"Block #{notification.height}\")\n\n    @zmq.on(ZMQTopic.TX)\n    async def handle_tx(notification):\n        print(f\"TX {notification.tx['txid']}\")\n\n    # Start the client\n    await zmq.start()\n\n    try:\n        # Keep running\n        while True:\n            await asyncio.sleep(1)\n    except KeyboardInterrupt:\n        print(\"\\nShutting down...\")\n    finally:\n        await zmq.stop()\n\nasyncio.run(main())\n</code></pre>"},{"location":"zmq/#advanced-features","title":"Advanced Features","text":""},{"location":"zmq/#custom-message-processing","title":"Custom Message Processing","text":"<pre><code>class BlockchainMonitor:\n    def __init__(self):\n        self.zmq_client = EvrmoreZMQClient()\n        self.rpc_client = EvrmoreClient()\n        self.blocks_processed = 0\n        self.transactions_processed = 0\n        self.asset_transfers = []\n\n    async def start(self):\n        # Register handlers\n        self.zmq_client.on_block(self.handle_block)\n        self.zmq_client.on_transaction(self.handle_transaction)\n\n        # Start the ZMQ client\n        await self.zmq_client.start()\n        print(\"Blockchain monitor started\")\n\n    async def stop(self):\n        await self.zmq_client.stop()\n        print(\"Blockchain monitor stopped\")\n\n    async def handle_block(self, notification):\n        block_hash = notification.hex\n        block = self.rpc_client.getblock(block_hash)\n\n        self.blocks_processed += 1\n        print(f\"New block: {block.hash} (height: {block.height})\")\n        print(f\"Block contains {len(block.tx)} transactions\")\n\n        # Analyze block data\n        if len(block.tx) &gt; 100:\n            print(f\"Large block detected: {len(block.tx)} transactions\")\n\n    async def handle_transaction(self, notification):\n        txid = notification.hex\n\n        try:\n            tx = self.rpc_client.getrawtransaction(txid, True)\n            self.transactions_processed += 1\n\n            # Check for asset transfers\n            for vout in tx.vout:\n                if \"asset\" in vout.get(\"scriptPubKey\", {}).get(\"asset\", {}):\n                    asset = vout[\"scriptPubKey\"][\"asset\"]\n                    print(f\"Asset transfer detected: {asset['name']} ({asset['amount']})\")\n\n                    self.asset_transfers.append({\n                        \"txid\": txid,\n                        \"asset\": asset[\"name\"],\n                        \"amount\": asset[\"amount\"],\n                        \"time\": tx.time if hasattr(tx, \"time\") else None\n                    })\n        except Exception as e:\n            print(f\"Error processing transaction {txid}: {e}\")\n</code></pre>"},{"location":"zmq/#error-handling","title":"Error Handling","text":"<pre><code>from evrmore_rpc.zmq import EvrmoreZMQError\n\ntry:\n    zmq.start()\nexcept EvrmoreZMQError as e:\n    print(f\"ZMQ error: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"zmq/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Use <code>set_lingering(0)</code> for fast shutdown</li> <li>Set appropriate cleanup timeouts</li> <li>Consider using async mode for better performance</li> <li>Monitor memory usage with large transaction volumes</li> </ul>"},{"location":"zmq/#see-also","title":"See Also","text":"<ul> <li>Getting Started for basic usage</li> <li>API Reference for detailed API docs</li> <li>Examples for more code samples</li> <li>Advanced Usage for production patterns</li> </ul>"},{"location":"zmq/#stress-test-results","title":"\ud83d\udcca Stress Test Results","text":"<p>Real benchmark results from the <code>stress_test.py</code> utility:</p> Mode Time RPS Avg (ms) Median Min Max Local Async 0.01 s 10442.42 0.59 0.50 0.39 1.84 Local Sync 0.06 s 1861.26 1.52 1.42 0.43 3.40 Remote Async 1.75 s 57.31 167.77 155.93 111 324 Remote Sync 1.86 s 53.83 160.39 163.26 112 310 <p>Tested with <code>getblockcount</code>, 100 requests, 10 concurrent workers</p>"},{"location":"zmq/#utilities-examples","title":"\ud83e\uddec Utilities &amp; Examples","text":"<pre><code>python3 -m evrmore_rpc.stress_test --sync --remote\n</code></pre> <p>Examples: - <code>readme_test.py</code> \u2014 basic usage demo - <code>stress_test.py</code> \u2014 concurrency performance test - <code>connection_pooling.py</code> \u2014 show pooled reuse efficiency - <code>flexible_config.py</code> \u2014 env var / conf / manual setup demo - <code>rpc_coverage.py</code> \u2014 validates full RPC method mapping - <code>zmq_notifications.py</code> \u2014 real-time block/tx decode stream</p>"},{"location":"zmq/#requirements","title":"\ud83e\uddea Requirements","text":"<ul> <li>Python 3.8+</li> <li>Evrmore daemon running with RPC and optional ZMQ endpoints</li> </ul>"},{"location":"zmq/#license","title":"\ud83e\udeaa License","text":"<p>MIT License \u2014 See LICENSE</p>"},{"location":"zmq/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>PRs welcome! Please lint, document, and include examples.</p> <pre><code>git clone https://github.com/manticoretechnologies/evrmore-rpc-dev\ncd evrmore-rpc\npython3 -m venv .venv &amp;&amp; source .venv/bin/activate\npip install -e .[dev]\n</code></pre> <p>Run tests with:</p> <pre><code>python3 -m evrmore_rpc.stress_test\n</code></pre>"},{"location":"zmq/#summary","title":"\ud83e\udded Summary","text":"<p><code>evrmore-rpc</code> is more than a wrapper \u2014 it's a full dev toolkit for Evrmore. Built for production-grade systems needing precision, flexibility, and real-time awareness. Perfect for explorers, exchanges, indexers, and power users.</p>"}]}