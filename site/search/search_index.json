{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Evrmore RPC Documentation","text":"<p>Welcome to the documentation for the <code>evrmore-rpc</code> package, a comprehensive, typed Python wrapper for the Evrmore blockchain with ZMQ and WebSockets support.</p>"},{"location":"#overview","title":"Overview","text":"<p>The <code>evrmore-rpc</code> package provides a clean, typed interface to interact with the Evrmore blockchain. It supports:</p> <ul> <li>Synchronous RPC calls via <code>EvrmoreClient</code></li> <li>Asynchronous RPC calls via <code>EvrmoreAsyncRPCClient</code></li> <li>Real-time blockchain notifications via ZMQ with <code>EvrmoreZMQClient</code></li> <li>WebSockets support for real-time updates with <code>EvrmoreWebSocketClient</code> and <code>EvrmoreWebSocketServer</code></li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#basic-installation","title":"Basic Installation","text":"<pre><code>pip install evrmore-rpc\n</code></pre>"},{"location":"#with-websockets-support","title":"With WebSockets Support","text":"<pre><code>pip install evrmore-rpc[websockets]\n</code></pre>"},{"location":"#full-installation-including-development-tools","title":"Full Installation (including development tools)","text":"<pre><code>pip install evrmore-rpc[full]\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#synchronous-api","title":"Synchronous API","text":"<pre><code>from evrmore_rpc import EvrmoreClient\n\n# Create a client\nclient = EvrmoreClient(\n    rpcuser=\"user\",\n    rpcpassword=\"password\",\n    rpchost=\"localhost\",\n    rpcport=8819,\n)\n\n# Get blockchain info\ninfo = client.getblockchaininfo()\nprint(f\"Current block height: {info.blocks}\")\nprint(f\"Chain: {info.chain}\")\nprint(f\"Difficulty: {info.difficulty}\")\n\n# Get a block\nblock_hash = client.getblockhash(1)\nblock = client.getblock(block_hash)\nprint(f\"Block #1 hash: {block.hash}\")\nprint(f\"Block #1 time: {block.time}\")\nprint(f\"Block #1 transactions: {len(block.tx)}\")\n\n# List assets\nassets = client.listassets()\nprint(f\"Found {len(assets)} assets\")\n</code></pre>"},{"location":"#asynchronous-api","title":"Asynchronous API","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreAsyncRPCClient\n\nasync def main():\n    # Create a client\n    async with EvrmoreAsyncRPCClient() as client:\n        # Get blockchain info and block in parallel\n        info, block_hash = await asyncio.gather(\n            client.getblockchaininfo(),\n            client.getblockhash(1)\n        )\n\n        # Get block details\n        block = await client.getblock(block_hash)\n\n        # Print results\n        print(f\"Current block height: {info.blocks}\")\n        print(f\"Block #1 hash: {block.hash}\")\n        print(f\"Block #1 transactions: {len(block.tx)}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#zmq-notifications","title":"ZMQ Notifications","text":"<pre><code>import asyncio\nfrom evrmore_rpc.zmq import EvrmoreZMQClient\n\nasync def handle_block(notification):\n    print(f\"New block: {notification.hex}\")\n\nasync def handle_transaction(notification):\n    print(f\"New transaction: {notification.hex}\")\n\nasync def main():\n    # Create a ZMQ client\n    client = EvrmoreZMQClient(\n        host=\"localhost\",\n        port=28332,\n    )\n\n    # Register handlers\n    client.on_block(handle_block)\n    client.on_transaction(handle_transaction)\n\n    # Start the client\n    await client.start()\n\n    # Keep running until interrupted\n    try:\n        while True:\n            await asyncio.sleep(1)\n    finally:\n        await client.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#websockets","title":"WebSockets","text":"<pre><code>import asyncio\nfrom evrmore_rpc.websockets import EvrmoreWebSocketClient\n\nasync def main():\n    # Create a WebSocket client\n    client = EvrmoreWebSocketClient(uri=\"ws://localhost:8765\")\n\n    # Connect to the WebSocket server\n    await client.connect()\n\n    # Subscribe to block and transaction notifications\n    await client.subscribe(\"blocks\")\n    await client.subscribe(\"transactions\")\n\n    # Process incoming messages\n    async for message in client:\n        if message.type == \"block\":\n            block_data = message.data\n            print(f\"New block: {block_data.hash} (height: {block_data.height})\")\n\n        elif message.type == \"transaction\":\n            tx_data = message.data\n            print(f\"New transaction: {tx_data.txid}\")\n\n    # Disconnect\n    await client.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#command-line-interface","title":"Command Line Interface","text":"<p>The <code>evrmore-rpc</code> package provides a command-line interface for executing RPC commands directly from the terminal.</p> <pre><code># Get blockchain info\nevrmore-rpc getblockchaininfo\n\n# Get a block by height\nevrmore-rpc getblockhash 100 | evrmore-rpc getblock -\n\n# List assets\nevrmore-rpc listassets\n\n# Start interactive mode\nevrmore-rpc -i\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>You can configure the CLI using command-line options or environment variables:</p> <pre><code># Using command-line options\nevrmore-rpc --rpcuser=user --rpcpassword=password getblockchaininfo\n\n# Using environment variables\nexport EVRMORE_RPC_USER=user\nexport EVRMORE_RPC_PASSWORD=password\nevrmore-rpc getblockchaininfo\n</code></pre>"},{"location":"#interactive-mode","title":"Interactive Mode","text":"<p>The CLI also supports an interactive mode for executing multiple commands:</p> <pre><code>evrmore-rpc -i\n&gt; getblockchaininfo\n&gt; getblockhash 100\n&gt; getblock &lt;result_from_previous_command&gt;\n&gt; exit\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Synchronous API</li> <li>Asynchronous API</li> <li>ZMQ Support</li> <li>WebSockets Support</li> <li>Models</li> <li>Examples</li> <li>Advanced Usage</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>The <code>evrmore-rpc</code> package includes several examples demonstrating its functionality:</p> <ul> <li>Basic RPC usage</li> <li>Asynchronous RPC usage</li> <li>ZMQ notifications</li> <li>WebSockets support</li> <li>Balance tracker for NFT exchange integration</li> <li>Interactive dashboards</li> <li>Blockchain analytics</li> </ul> <p>See the examples directory for more information.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"advanced/","title":"Advanced Usage","text":"<p>This document covers advanced usage patterns for the <code>evrmore-rpc</code> package, including performance optimization, error handling, and integration with other libraries.</p>"},{"location":"advanced/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/#connection-pooling","title":"Connection Pooling","text":"<p>When making multiple RPC calls, it's more efficient to reuse the same client instance rather than creating a new one for each call:</p> <pre><code>from evrmore_rpc import EvrmoreRPCClient\n\n# Create a single client instance\nclient = EvrmoreRPCClient()\n\n# Reuse the client for multiple calls\ninfo = client.getblockchaininfo()\nblock_hash = client.getblockhash(1)\nblock = client.getblock(block_hash)\n</code></pre>"},{"location":"advanced/#parallel-execution-with-async-api","title":"Parallel Execution with Async API","text":"<p>For applications that need to make many RPC calls, the asynchronous API can significantly improve performance by executing calls concurrently:</p> <pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreAsyncRPCClient\n\nasync def main():\n    async with EvrmoreAsyncRPCClient() as client:\n        # Execute multiple commands concurrently\n        info, block_hash, mempool_info = await asyncio.gather(\n            client.getblockchaininfo(),\n            client.getblockhash(1),\n            client.getmempoolinfo()\n        )\n\n        # Get block details\n        block = await client.getblock(block_hash)\n\n        # Print results\n        print(f\"Current block height: {info.blocks}\")\n        print(f\"Block #1 hash: {block.hash}\")\n        print(f\"Mempool size: {mempool_info['size']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"advanced/#batch-processing","title":"Batch Processing","text":"<p>For processing large amounts of data, use batch processing to avoid memory issues:</p> <pre><code>from evrmore_rpc import EvrmoreRPCClient\n\ndef process_blocks_in_batches(start_height, end_height, batch_size=100):\n    client = EvrmoreRPCClient()\n\n    for batch_start in range(start_height, end_height, batch_size):\n        batch_end = min(batch_start + batch_size, end_height)\n        print(f\"Processing blocks {batch_start} to {batch_end}\")\n\n        for height in range(batch_start, batch_end):\n            block_hash = client.getblockhash(height)\n            block = client.getblock(block_hash)\n            # Process block data\n            print(f\"Block {height}: {len(block.tx)} transactions\")\n\n# Process blocks 1 to 1000 in batches of 100\nprocess_blocks_in_batches(1, 1000, 100)\n</code></pre>"},{"location":"advanced/#error-handling","title":"Error Handling","text":""},{"location":"advanced/#robust-error-handling","title":"Robust Error Handling","text":"<p>Implement robust error handling to deal with network issues, node downtime, and other potential problems:</p> <pre><code>from evrmore_rpc import EvrmoreRPCClient, EvrmoreRPCError\nimport time\n\ndef get_block_with_retry(height, max_retries=3, retry_delay=1):\n    client = EvrmoreRPCClient()\n\n    for attempt in range(max_retries):\n        try:\n            block_hash = client.getblockhash(height)\n            block = client.getblock(block_hash)\n            return block\n        except EvrmoreRPCError as e:\n            print(f\"Error on attempt {attempt + 1}/{max_retries}: {e}\")\n            if attempt &lt; max_retries - 1:\n                print(f\"Retrying in {retry_delay} seconds...\")\n                time.sleep(retry_delay)\n                retry_delay *= 2  # Exponential backoff\n            else:\n                print(\"Max retries reached, giving up.\")\n                raise\n        except Exception as e:\n            print(f\"Unexpected error: {e}\")\n            raise\n\n# Try to get block 100 with retries\ntry:\n    block = get_block_with_retry(100)\n    print(f\"Block 100 has {len(block.tx)} transactions\")\nexcept Exception as e:\n    print(f\"Failed to get block: {e}\")\n</code></pre>"},{"location":"advanced/#async-error-handling","title":"Async Error Handling","text":"<p>For asynchronous code, use proper async error handling:</p> <pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreAsyncRPCClient, EvrmoreRPCError\n\nasync def get_block_with_retry_async(height, max_retries=3, retry_delay=1):\n    async with EvrmoreAsyncRPCClient() as client:\n        for attempt in range(max_retries):\n            try:\n                block_hash = await client.getblockhash(height)\n                block = await client.getblock(block_hash)\n                return block\n            except EvrmoreRPCError as e:\n                print(f\"Error on attempt {attempt + 1}/{max_retries}: {e}\")\n                if attempt &lt; max_retries - 1:\n                    print(f\"Retrying in {retry_delay} seconds...\")\n                    await asyncio.sleep(retry_delay)\n                    retry_delay *= 2  # Exponential backoff\n                else:\n                    print(\"Max retries reached, giving up.\")\n                    raise\n            except Exception as e:\n                print(f\"Unexpected error: {e}\")\n                raise\n\nasync def main():\n    try:\n        block = await get_block_with_retry_async(100)\n        print(f\"Block 100 has {len(block.tx)} transactions\")\n    except Exception as e:\n        print(f\"Failed to get block: {e}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"advanced/#integration-with-other-libraries","title":"Integration with Other Libraries","text":""},{"location":"advanced/#integration-with-fastapi","title":"Integration with FastAPI","text":"<p>Integrate with FastAPI to create a blockchain API:</p> <pre><code>from fastapi import FastAPI, HTTPException\nfrom evrmore_rpc import EvrmoreRPCClient, EvrmoreRPCError\n\napp = FastAPI(title=\"Evrmore API\", description=\"API for Evrmore blockchain\")\nclient = EvrmoreRPCClient()\n\n@app.get(\"/blockchain/info\")\ndef get_blockchain_info():\n    try:\n        info = client.getblockchaininfo()\n        return {\n            \"blocks\": info.blocks,\n            \"headers\": info.headers,\n            \"bestblockhash\": info.bestblockhash,\n            \"difficulty\": float(info.difficulty),\n            \"chain\": info.chain\n        }\n    except EvrmoreRPCError as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/block/{height}\")\ndef get_block(height: int):\n    try:\n        block_hash = client.getblockhash(height)\n        block = client.getblock(block_hash)\n        return {\n            \"hash\": block.hash,\n            \"height\": block.height,\n            \"time\": block.time,\n            \"tx_count\": len(block.tx),\n            \"size\": block.size\n        }\n    except EvrmoreRPCError as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/transaction/{txid}\")\ndef get_transaction(txid: str):\n    try:\n        tx = client.getrawtransaction(txid, True)\n        return {\n            \"txid\": tx.txid,\n            \"size\": tx.size,\n            \"vsize\": tx.vsize,\n            \"version\": tx.version,\n            \"locktime\": tx.locktime,\n            \"vin_count\": len(tx.vin),\n            \"vout_count\": len(tx.vout)\n        }\n    except EvrmoreRPCError as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"advanced/#integration-with-async-fastapi","title":"Integration with Async FastAPI","text":"<p>For better performance, integrate with FastAPI using the async client:</p> <pre><code>from fastapi import FastAPI, HTTPException\nfrom evrmore_rpc import EvrmoreAsyncRPCClient, EvrmoreRPCError\n\napp = FastAPI(title=\"Evrmore Async API\", description=\"Async API for Evrmore blockchain\")\nclient = EvrmoreAsyncRPCClient()\n\n@app.on_event(\"startup\")\nasync def startup():\n    await client.initialize()\n\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    pass  # No cleanup needed for EvrmoreAsyncRPCClient\n\n@app.get(\"/blockchain/info\")\nasync def get_blockchain_info():\n    try:\n        info = await client.getblockchaininfo()\n        return {\n            \"blocks\": info.blocks,\n            \"headers\": info.headers,\n            \"bestblockhash\": info.bestblockhash,\n            \"difficulty\": float(info.difficulty),\n            \"chain\": info.chain\n        }\n    except EvrmoreRPCError as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/block/{height}\")\nasync def get_block(height: int):\n    try:\n        block_hash = await client.getblockhash(height)\n        block = await client.getblock(block_hash)\n        return {\n            \"hash\": block.hash,\n            \"height\": block.height,\n            \"time\": block.time,\n            \"tx_count\": len(block.tx),\n            \"size\": block.size\n        }\n    except EvrmoreRPCError as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"advanced/#integration-with-sqlalchemy","title":"Integration with SQLAlchemy","text":"<p>Store blockchain data in a database using SQLAlchemy:</p> <pre><code>from sqlalchemy import create_engine, Column, Integer, String, Float, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, relationship\nfrom evrmore_rpc import EvrmoreRPCClient\n\n# Set up SQLAlchemy\nBase = declarative_base()\nengine = create_engine(\"sqlite:///blockchain.db\")\nSession = sessionmaker(bind=engine)\n\n# Define models\nclass Block(Base):\n    __tablename__ = \"blocks\"\n\n    height = Column(Integer, primary_key=True)\n    hash = Column(String, unique=True, nullable=False)\n    time = Column(Integer, nullable=False)\n    size = Column(Integer, nullable=False)\n    tx_count = Column(Integer, nullable=False)\n    transactions = relationship(\"Transaction\", back_populates=\"block\")\n\nclass Transaction(Base):\n    __tablename__ = \"transactions\"\n\n    txid = Column(String, primary_key=True)\n    block_height = Column(Integer, ForeignKey(\"blocks.height\"), nullable=False)\n    size = Column(Integer, nullable=False)\n    time = Column(Integer, nullable=False)\n    block = relationship(\"Block\", back_populates=\"transactions\")\n\n# Create tables\nBase.metadata.create_all(engine)\n\n# Function to sync blockchain data\ndef sync_blockchain_data(start_height, end_height):\n    client = EvrmoreRPCClient()\n    session = Session()\n\n    try:\n        for height in range(start_height, end_height + 1):\n            # Check if block already exists\n            existing_block = session.query(Block).filter_by(height=height).first()\n            if existing_block:\n                print(f\"Block {height} already exists, skipping\")\n                continue\n\n            # Get block data\n            block_hash = client.getblockhash(height)\n            block_data = client.getblock(block_hash)\n\n            # Create block record\n            block = Block(\n                height=height,\n                hash=block_data.hash,\n                time=block_data.time,\n                size=block_data.size,\n                tx_count=len(block_data.tx)\n            )\n            session.add(block)\n\n            # Create transaction records\n            for txid in block_data.tx:\n                tx_data = client.getrawtransaction(txid, True)\n                tx = Transaction(\n                    txid=txid,\n                    block_height=height,\n                    size=tx_data.size,\n                    time=block_data.time\n                )\n                session.add(tx)\n\n            # Commit after each block\n            session.commit()\n            print(f\"Synced block {height} with {len(block_data.tx)} transactions\")\n\n    except Exception as e:\n        session.rollback()\n        print(f\"Error: {e}\")\n    finally:\n        session.close()\n\n# Sync blocks 1 to 100\nsync_blockchain_data(1, 100)\n</code></pre>"},{"location":"advanced/#advanced-zmq-usage","title":"Advanced ZMQ Usage","text":""},{"location":"advanced/#custom-zmq-message-processing","title":"Custom ZMQ Message Processing","text":"<p>Process ZMQ messages with custom logic:</p> <pre><code>import asyncio\nfrom evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\nfrom evrmore_rpc import EvrmoreRPCClient\n\nclass BlockchainMonitor:\n    def __init__(self):\n        self.zmq_client = EvrmoreZMQClient()\n        self.rpc_client = EvrmoreRPCClient()\n        self.blocks_processed = 0\n        self.transactions_processed = 0\n        self.asset_transfers = []\n\n    async def start(self):\n        # Register handlers\n        self.zmq_client.on_block(self.handle_block)\n        self.zmq_client.on_transaction(self.handle_transaction)\n\n        # Start the ZMQ client\n        await self.zmq_client.start()\n        print(\"Blockchain monitor started\")\n\n    async def stop(self):\n        await self.zmq_client.stop()\n        print(\"Blockchain monitor stopped\")\n\n    async def handle_block(self, notification):\n        block_hash = notification.hex\n        block = self.rpc_client.getblock(block_hash)\n\n        self.blocks_processed += 1\n        print(f\"New block: {block.hash} (height: {block.height})\")\n        print(f\"Block contains {len(block.tx)} transactions\")\n\n        # Analyze block data\n        if len(block.tx) &gt; 100:\n            print(f\"Large block detected: {len(block.tx)} transactions\")\n\n    async def handle_transaction(self, notification):\n        txid = notification.hex\n\n        try:\n            tx = self.rpc_client.getrawtransaction(txid, True)\n            self.transactions_processed += 1\n\n            # Check for asset transfers\n            for vout in tx.vout:\n                if \"asset\" in vout.get(\"scriptPubKey\", {}).get(\"asset\", {}):\n                    asset = vout[\"scriptPubKey\"][\"asset\"]\n                    print(f\"Asset transfer detected: {asset['name']} ({asset['amount']})\")\n\n                    self.asset_transfers.append({\n                        \"txid\": txid,\n                        \"asset\": asset[\"name\"],\n                        \"amount\": asset[\"amount\"],\n                        \"time\": tx.time if hasattr(tx, \"time\") else None\n                    })\n        except Exception as e:\n            print(f\"Error processing transaction {txid}: {e}\")\n\nasync def main():\n    monitor = BlockchainMonitor()\n\n    try:\n        await monitor.start()\n\n        # Keep running until interrupted\n        while True:\n            await asyncio.sleep(1)\n\n    except KeyboardInterrupt:\n        print(\"Interrupted by user\")\n    finally:\n        await monitor.stop()\n\n        # Print summary\n        print(f\"Processed {monitor.blocks_processed} blocks\")\n        print(f\"Processed {monitor.transactions_processed} transactions\")\n        print(f\"Detected {len(monitor.asset_transfers)} asset transfers\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"advanced/#advanced-websockets-usage","title":"Advanced WebSockets Usage","text":""},{"location":"advanced/#custom-websocket-server","title":"Custom WebSocket Server","text":"<p>Create a custom WebSocket server with additional functionality:</p> <pre><code>import asyncio\nimport json\nimport logging\nfrom typing import Dict, Set, Any\n\nimport websockets\nfrom websockets.server import WebSocketServerProtocol\n\nfrom evrmore_rpc import EvrmoreRPCClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"custom-websocket-server\")\n\nclass CustomWebSocketServer:\n    def __init__(self, host=\"localhost\", port=8765):\n        self.host = host\n        self.port = port\n        self.clients: Set[WebSocketServerProtocol] = set()\n        self.subscriptions: Dict[str, Set[WebSocketServerProtocol]] = {\n            \"blocks\": set(),\n            \"transactions\": set(),\n            \"assets\": set(),\n            \"mempool\": set()\n        }\n        self.rpc_client = EvrmoreRPCClient()\n        self.zmq_client = EvrmoreZMQClient()\n        self.server = None\n\n    async def start(self):\n        # Register ZMQ handlers\n        self.zmq_client.on_block(self.handle_block)\n        self.zmq_client.on_transaction(self.handle_transaction)\n\n        # Start ZMQ client\n        await self.zmq_client.start()\n\n        # Start WebSocket server\n        self.server = await websockets.serve(\n            self.handle_client,\n            self.host,\n            self.port\n        )\n\n        logger.info(f\"WebSocket server started on ws://{self.host}:{self.port}\")\n\n    async def stop(self):\n        # Stop WebSocket server\n        if self.server:\n            self.server.close()\n            await self.server.wait_closed()\n\n        # Stop ZMQ client\n        await self.zmq_client.stop()\n\n        logger.info(\"WebSocket server stopped\")\n\n    async def handle_client(self, websocket: WebSocketServerProtocol, path: str):\n        # Register client\n        self.clients.add(websocket)\n        logger.info(f\"Client connected: {websocket.remote_address}\")\n\n        try:\n            async for message in websocket:\n                try:\n                    data = json.loads(message)\n\n                    if \"action\" in data and \"topic\" in data:\n                        action = data[\"action\"]\n                        topic = data[\"topic\"]\n\n                        if action == \"subscribe\":\n                            if topic in self.subscriptions:\n                                self.subscriptions[topic].add(websocket)\n                                await websocket.send(json.dumps({\n                                    \"type\": \"subscription\",\n                                    \"status\": \"success\",\n                                    \"topic\": topic\n                                }))\n                                logger.info(f\"Client subscribed to {topic}\")\n                            else:\n                                await websocket.send(json.dumps({\n                                    \"type\": \"error\",\n                                    \"message\": f\"Invalid topic: {topic}\"\n                                }))\n\n                        elif action == \"unsubscribe\":\n                            if topic in self.subscriptions and websocket in self.subscriptions[topic]:\n                                self.subscriptions[topic].remove(websocket)\n                                await websocket.send(json.dumps({\n                                    \"type\": \"subscription\",\n                                    \"status\": \"success\",\n                                    \"topic\": topic,\n                                    \"action\": \"unsubscribe\"\n                                }))\n                                logger.info(f\"Client unsubscribed from {topic}\")\n                            else:\n                                await websocket.send(json.dumps({\n                                    \"type\": \"error\",\n                                    \"message\": f\"Not subscribed to topic: {topic}\"\n                                }))\n\n                        else:\n                            await websocket.send(json.dumps({\n                                \"type\": \"error\",\n                                \"message\": f\"Invalid action: {action}\"\n                            }))\n\n                    elif \"command\" in data:\n                        # Handle RPC commands\n                        command = data[\"command\"]\n                        params = data.get(\"params\", [])\n\n                        try:\n                            result = getattr(self.rpc_client, command)(*params)\n                            await websocket.send(json.dumps({\n                                \"type\": \"command\",\n                                \"command\": command,\n                                \"result\": result\n                            }))\n                        except Exception as e:\n                            await websocket.send(json.dumps({\n                                \"type\": \"error\",\n                                \"message\": f\"Command failed: {str(e)}\"\n                            }))\n\n                    else:\n                        await websocket.send(json.dumps({\n                            \"type\": \"error\",\n                            \"message\": \"Invalid message format\"\n                        }))\n\n                except json.JSONDecodeError:\n                    await websocket.send(json.dumps({\n                        \"type\": \"error\",\n                        \"message\": \"Invalid JSON\"\n                    }))\n\n        except websockets.exceptions.ConnectionClosed:\n            logger.info(f\"Client disconnected: {websocket.remote_address}\")\n        finally:\n            # Unregister client\n            self.clients.remove(websocket)\n            for subscribers in self.subscriptions.values():\n                if websocket in subscribers:\n                    subscribers.remove(websocket)\n\n    async def handle_block(self, notification):\n        block_hash = notification.hex\n\n        try:\n            # Get block details\n            block = self.rpc_client.getblock(block_hash)\n\n            # Prepare message\n            message = {\n                \"type\": \"block\",\n                \"data\": {\n                    \"hash\": block.hash,\n                    \"height\": block.height,\n                    \"time\": block.time,\n                    \"tx_count\": len(block.tx),\n                    \"size\": block.size\n                }\n            }\n\n            # Broadcast to subscribers\n            await self.broadcast(\"blocks\", message)\n\n            # Update mempool info\n            await self.update_mempool()\n\n        except Exception as e:\n            logger.error(f\"Error handling block: {e}\")\n\n    async def handle_transaction(self, notification):\n        txid = notification.hex\n\n        try:\n            # Get transaction details\n            tx = self.rpc_client.getrawtransaction(txid, True)\n\n            # Prepare message\n            message = {\n                \"type\": \"transaction\",\n                \"data\": {\n                    \"txid\": tx.txid,\n                    \"size\": tx.size,\n                    \"vsize\": tx.vsize,\n                    \"version\": tx.version,\n                    \"locktime\": tx.locktime,\n                    \"vin_count\": len(tx.vin),\n                    \"vout_count\": len(tx.vout)\n                }\n            }\n\n            # Broadcast to subscribers\n            await self.broadcast(\"transactions\", message)\n\n            # Check for asset transfers\n            for vout in tx.vout:\n                if \"asset\" in vout.get(\"scriptPubKey\", {}).get(\"asset\", {}):\n                    asset = vout[\"scriptPubKey\"][\"asset\"]\n\n                    # Prepare asset message\n                    asset_message = {\n                        \"type\": \"asset\",\n                        \"data\": {\n                            \"txid\": tx.txid,\n                            \"asset\": asset[\"name\"],\n                            \"amount\": asset[\"amount\"],\n                            \"type\": \"transfer\"\n                        }\n                    }\n\n                    # Broadcast to asset subscribers\n                    await self.broadcast(\"assets\", asset_message)\n\n        except Exception as e:\n            logger.error(f\"Error handling transaction: {e}\")\n\n    async def update_mempool(self):\n        try:\n            # Get mempool info\n            mempool = self.rpc_client.getmempoolinfo()\n\n            # Prepare message\n            message = {\n                \"type\": \"mempool\",\n                \"data\": {\n                    \"size\": mempool[\"size\"],\n                    \"bytes\": mempool[\"bytes\"],\n                    \"usage\": mempool[\"usage\"]\n                }\n            }\n\n            # Broadcast to subscribers\n            await self.broadcast(\"mempool\", message)\n\n        except Exception as e:\n            logger.error(f\"Error updating mempool: {e}\")\n\n    async def broadcast(self, topic: str, message: Dict[str, Any]):\n        if topic in self.subscriptions:\n            subscribers = self.subscriptions[topic]\n            if subscribers:\n                message_str = json.dumps(message)\n                await asyncio.gather(\n                    *[client.send(message_str) for client in subscribers],\n                    return_exceptions=True\n                )\n\nasync def main():\n    server = CustomWebSocketServer()\n\n    try:\n        await server.start()\n\n        # Keep running until interrupted\n        while True:\n            await asyncio.sleep(1)\n\n    except KeyboardInterrupt:\n        print(\"Interrupted by user\")\n    finally:\n        await server.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"advanced/#security-considerations","title":"Security Considerations","text":""},{"location":"advanced/#secure-rpc-configuration","title":"Secure RPC Configuration","text":"<p>Ensure your Evrmore node's RPC configuration is secure:</p> <pre><code># evrmore.conf\nrpcuser=your_username\nrpcpassword=your_strong_password\nrpcport=8819\nrpcallowip=127.0.0.1\n</code></pre>"},{"location":"advanced/#environment-variables-for-credentials","title":"Environment Variables for Credentials","text":"<p>Use environment variables for RPC credentials instead of hardcoding them:</p> <pre><code>import os\nfrom evrmore_rpc import EvrmoreRPCClient\n\n# Get credentials from environment variables\nrpcuser = os.environ.get(\"EVRMORE_RPC_USER\")\nrpcpassword = os.environ.get(\"EVRMORE_RPC_PASSWORD\")\n\n# Create client with credentials\nclient = EvrmoreRPCClient(rpcuser=rpcuser, rpcpassword=rpcpassword)\n</code></pre>"},{"location":"advanced/#rate-limiting","title":"Rate Limiting","text":"<p>Implement rate limiting to prevent overloading the node:</p> <pre><code>import time\nfrom evrmore_rpc import EvrmoreRPCClient\n\nclass RateLimitedClient:\n    def __init__(self, max_calls_per_second=5):\n        self.client = EvrmoreRPCClient()\n        self.max_calls_per_second = max_calls_per_second\n        self.call_times = []\n\n    def _check_rate_limit(self):\n        \"\"\"Check if we're exceeding the rate limit and wait if necessary.\"\"\"\n        now = time.time()\n\n        # Remove old calls from the list\n        self.call_times = [t for t in self.call_times if now - t &lt; 1.0]\n\n        # If we've made too many calls in the last second, wait\n        if len(self.call_times) &gt;= self.max_calls_per_second:\n            wait_time = 1.0 - (now - self.call_times[0])\n            if wait_time &gt; 0:\n                time.sleep(wait_time)\n                now = time.time()  # Update current time\n\n        # Record this call\n        self.call_times.append(now)\n\n    def __getattr__(self, name):\n        \"\"\"Forward method calls to the underlying client with rate limiting.\"\"\"\n        method = getattr(self.client, name)\n\n        def wrapper(*args, **kwargs):\n            self._check_rate_limit()\n            return method(*args, **kwargs)\n\n        return wrapper\n\n# Use the rate-limited client\nclient = RateLimitedClient(max_calls_per_second=5)\ninfo = client.getblockchaininfo()\n</code></pre>"},{"location":"advanced/#debugging-and-troubleshooting","title":"Debugging and Troubleshooting","text":""},{"location":"advanced/#logging","title":"Logging","text":"<p>Set up logging to help with debugging:</p> <pre><code>import logging\nfrom evrmore_rpc import EvrmoreRPCClient, EvrmoreRPCError\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    filename=\"evrmore_rpc.log\"\n)\nlogger = logging.getLogger(\"evrmore_rpc\")\n\n# Create client\nclient = EvrmoreRPCClient()\n\n# Use client with logging\ntry:\n    logger.info(\"Getting blockchain info\")\n    info = client.getblockchaininfo()\n    logger.info(f\"Current block height: {info.blocks}\")\n\n    logger.info(f\"Getting block at height 1\")\n    block_hash = client.getblockhash(1)\n    block = client.getblock(block_hash)\n    logger.info(f\"Block #1 hash: {block.hash}\")\n\nexcept EvrmoreRPCError as e:\n    logger.error(f\"RPC error: {e}\")\nexcept Exception as e:\n    logger.exception(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"advanced/#verbose-mode","title":"Verbose Mode","text":"<p>Enable verbose mode to see more details about RPC calls:</p> <pre><code>import logging\nfrom evrmore_rpc import EvrmoreRPCClient\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(\"evrmore_rpc\")\n\n# Create client with verbose mode\nclient = EvrmoreRPCClient(verbose=True)\n\n# Make RPC calls\ninfo = client.getblockchaininfo()\n</code></pre>"},{"location":"advanced/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"advanced/#connection-refused","title":"Connection Refused","text":"<p>If you get a \"Connection refused\" error:</p> <ol> <li>Check if the Evrmore node is running</li> <li>Verify the RPC port is correct</li> <li>Check if the node is configured to accept RPC connections</li> <li>Ensure the firewall allows connections to the RPC port</li> </ol>"},{"location":"advanced/#authentication-failed","title":"Authentication Failed","text":"<p>If you get an authentication error:</p> <ol> <li>Check if the RPC username and password are correct</li> <li>Verify the RPC credentials in the Evrmore configuration file</li> <li>Restart the Evrmore node after changing the configuration</li> </ol>"},{"location":"advanced/#timeout","title":"Timeout","text":"<p>If RPC calls time out:</p> <ol> <li>Check if the node is syncing or processing a large number of transactions</li> <li>Increase the timeout value when creating the client</li> <li>Consider using a more powerful machine for the node</li> </ol> <pre><code>from evrmore_rpc import EvrmoreRPCClient\n\n# Create client with increased timeout\nclient = EvrmoreRPCClient(timeout=60)  # 60 seconds timeout\n</code></pre>"},{"location":"api/","title":"Api","text":""},{"location":"api/#zmq-client-api","title":"ZMQ Client API","text":"<p>The ZMQ client provides a seamless API that works in both synchronous and asynchronous contexts.</p>"},{"location":"api/#initialization","title":"Initialization","text":"<pre><code>from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\n# Default initialization\nzmq = EvrmoreZMQClient()  # Default host: 127.0.0.1, port: 28332\n\n# Custom ZMQ endpoint\nzmq = EvrmoreZMQClient(zmq_host=\"192.168.1.100\", zmq_port=28333)\n\n# Specific topics (default is all topics)\nzmq = EvrmoreZMQClient(topics=[ZMQTopic.HASH_BLOCK, ZMQTopic.HASH_TX])\n</code></pre>"},{"location":"api/#configuration","title":"Configuration","text":"<pre><code># Set lingering time for fast shutdown (0 = no lingering)\nzmq.set_lingering(0)\n\n# Set cleanup timeouts for graceful shutdown\nzmq.set_cleanup_timeouts(thread_timeout=0.1, task_timeout=0.1)\n\n# Force synchronous mode regardless of context\nzmq.force_sync()\n\n# Force asynchronous mode regardless of context\nzmq.force_async()\n\n# Reset to auto-detect mode (default behavior)\nzmq.reset()\n</code></pre>"},{"location":"api/#starting-and-stopping","title":"Starting and Stopping","text":"<pre><code># Start the client - works in both sync and async contexts\nzmq.start()  # In sync context\nawait zmq.start()  # In async context\n\n# Stop the client - works in both sync and async contexts\nzmq.stop()  # In sync context\nawait zmq.stop()  # In async context\n\n# Force immediate exit (for emergencies)\nzmq.stop(force=True)  # Exits program immediately\n</code></pre>"},{"location":"api/#event-handlers","title":"Event Handlers","text":"<pre><code># Register a handler for a topic with decorator\n@zmq.on(ZMQTopic.HASH_BLOCK)\ndef on_new_block(notification):\n    print(f\"New block: {notification.hex}\")\n\n@zmq.on(ZMQTopic.HASH_TX)\ndef on_new_tx(notification):\n    print(f\"New transaction: {notification.hex}\")\n</code></pre>"},{"location":"api/#example-zmq-synchronous-usage","title":"Example: ZMQ Synchronous Usage","text":"<p>```python import signal import sys import time from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic</p>"},{"location":"api/#initialize-client","title":"Initialize client","text":"<p>zmq = EvrmoreZMQClient() zmq.set_lingering(0)  # For fast shutdown</p>"},{"location":"api/#handle-ctrlc-for-clean-shutdown","title":"Handle Ctrl+C for clean shutdown","text":"<p>def signal_handler(sig, frame):     print(\"\\nShutting down...\")     zmq.stop()     print(\"Goodbye!\")     sys.exit(0)</p> <p>signal.signal(signal.SIGINT, signal_handler)</p>"},{"location":"api/#register-handlers","title":"Register handlers","text":"<p>@zmq.on(ZMQTopic.HASH_BLOCK) def on_new_block(notification):     print(f\"New block: {notification.hex}\")</p> <p>@zmq.on(ZMQTopic.HASH_TX) def on_new_transaction(notification):     print(f\"New transaction: {notification.hex}\")</p>"},{"location":"api/#start-the-client","title":"Start the client","text":"<p>zmq.start()</p>"},{"location":"api/#main-loop","title":"Main loop","text":"<p>try:     while True:         print(\"Waiting for events...\")         time.sleep(5) except KeyboardInterrupt:     print(\"\\nShutting down...\")     zmq.stop()</p>"},{"location":"api/#example-zmq-asynchronous-usage","title":"Example: ZMQ Asynchronous Usage","text":"<p>```python import asyncio import signal import sys from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic</p>"},{"location":"api/#create-event-for-shutdown","title":"Create event for shutdown","text":"<p>shutdown_event = asyncio.Event()</p>"},{"location":"api/#signal-handler-for-ctrlc","title":"Signal handler for Ctrl+C","text":"<p>def signal_handler(sig, frame):     print(\"\\nShutdown initiated...\")     if not shutdown_event.is_set():         shutdown_event.set()</p> <p>signal.signal(signal.SIGINT, signal_handler)</p> <p>async def main():     # Initialize client     zmq = EvrmoreZMQClient()     zmq.set_lingering(0)  # For fast shutdown</p> <pre><code># Register handlers\n@zmq.on(ZMQTopic.HASH_BLOCK)\ndef on_new_block(notification):\n    print(f\"New block: {notification.hex}\")\n\n@zmq.on(ZMQTopic.HASH_TX)\ndef on_new_transaction(notification):\n    print(f\"New transaction: {notification.hex}\")\n\n# Start the client\nawait zmq.start()\n\ntry:\n    # Wait for shutdown signal\n    while not shutdown_event.is_set():\n        print(\"Waiting for events...\")\n        try:\n            await asyncio.wait_for(shutdown_event.wait(), timeout=5)\n        except asyncio.TimeoutError:\n            continue\nexcept asyncio.CancelledError:\n    pass\nfinally:\n    # Stop the client\n    await zmq.stop()\n    print(\"Client stopped cleanly.\")\n</code></pre>"},{"location":"api/#run-the-main-function","title":"Run the main function","text":"<p>if name == \"main\":     try:         asyncio.run(main())         print(\"Clean exit.\")     except KeyboardInterrupt:         print(\"Forced exit.\")</p>"},{"location":"api/#example-emergency-fast-exit","title":"Example: Emergency Fast Exit","text":"<p>```python import signal import sys from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic</p>"},{"location":"api/#initialize-client_1","title":"Initialize client","text":"<p>zmq = EvrmoreZMQClient() zmq.set_lingering(0)  # Try to set fast shutdown</p>"},{"location":"api/#track-if-first-ctrlc-press","title":"Track if first Ctrl+C press","text":"<p>first_interrupt = True</p>"},{"location":"api/#handle-ctrlc","title":"Handle Ctrl+C","text":"<p>def signal_handler(sig, frame):     global first_interrupt</p> <pre><code>if first_interrupt:\n    print(\"\\nPress Ctrl+C again for immediate exit\")\n    print(\"Attempting normal shutdown...\")\n    first_interrupt = False\n    zmq.stop()  # Try normal shutdown\nelse:\n    print(\"\\nForce exiting immediately!\")\n    zmq.stop(force=True)  # Force immediate exit\n</code></pre> <p>signal.signal(signal.SIGINT, signal_handler)</p>"},{"location":"api/#register-handler","title":"Register handler","text":"<p>@zmq.on(ZMQTopic.HASH_BLOCK) def on_new_block(notification):     print(f\"New block: {notification.hex}\")</p>"},{"location":"api/#start-the-client_1","title":"Start the client","text":"<p>zmq.start()</p>"},{"location":"api/#main-loop-never-reached-with-double-ctrlc","title":"Main loop (never reached with double Ctrl+C)","text":"<p>print(\"Press Ctrl+C once for normal exit, twice for immediate exit\") try:     import time     while True:         time.sleep(1) except Exception:     pass </p>"},{"location":"api_reference/","title":"API Reference","text":"<p>This page documents the main classes and methods of the Evrmore RPC library.</p>"},{"location":"api_reference/#overview","title":"Overview","text":"<p>The Evrmore RPC library provides a comprehensive API for interacting with the Evrmore blockchain. The main components are:</p> <ul> <li>Synchronous API: For standard synchronous programming</li> <li>Asynchronous API: For async/await programming model</li> <li>ZMQ Support: For real-time blockchain notifications</li> <li>WebSockets Support: For real-time web applications</li> <li>Models: Type-safe data structures for blockchain data</li> </ul>"},{"location":"api_reference/#main-classes","title":"Main Classes","text":"<p>The library provides several client classes to interact with the Evrmore blockchain:</p> Class Description Import Path <code>EvrmoreClient</code> Main synchronous client <code>from evrmore_rpc import EvrmoreClient</code> <code>EvrmoreAsyncRPCClient</code> Asynchronous RPC client <code>from evrmore_rpc import EvrmoreAsyncRPCClient</code> <code>EvrmoreZMQClient</code> ZMQ notifications client <code>from evrmore_rpc.zmq import EvrmoreZMQClient</code> <code>EvrmoreWebSocketClient</code> WebSocket client <code>from evrmore_rpc.websockets import EvrmoreWebSocketClient</code> <code>EvrmoreWebSocketServer</code> WebSocket server <code>from evrmore_rpc.websockets import EvrmoreWebSocketServer</code>"},{"location":"api_reference/#quick-example","title":"Quick Example","text":"<pre><code>from evrmore_rpc import EvrmoreClient\n\n# Create a client\nclient = EvrmoreClient()\n\n# Get blockchain info\ninfo = client.getblockchaininfo()\nprint(f\"Current block height: {info.blocks}\")\nprint(f\"Chain: {info.chain}\")\nprint(f\"Difficulty: {info.difficulty}\")\n\n# Get a block\nblock_hash = client.getblockhash(1)\nblock = client.getblock(block_hash)\nprint(f\"Block #1 hash: {block.hash}\")\nprint(f\"Block #1 time: {block.time}\")\nprint(f\"Block #1 transactions: {len(block.tx)}\")\n</code></pre>"},{"location":"api_reference/#api-design","title":"API Design","text":"<p>The API is designed with several key principles in mind:</p> <ol> <li>Type Safety: All methods and responses are fully typed with proper type hints.</li> <li>Consistency: Methods follow a consistent naming and parameter pattern.</li> <li>Pythonic: API feels natural to Python developers.</li> <li>Performance: Optimized for efficient blockchain interactions.</li> </ol>"},{"location":"api_reference/#further-reading","title":"Further Reading","text":"<p>Explore the specific sections for more detailed information:</p> <ul> <li>Synchronous API: For traditional synchronous programming</li> <li>Asynchronous API: For async/await programming model</li> <li>ZMQ Support: For real-time blockchain notifications</li> <li>WebSockets Support: For real-time web applications</li> <li>Models: Type-safe data structures for blockchain data </li> </ul>"},{"location":"async_api/","title":"Asynchronous API","text":"<p>The <code>evrmore-rpc</code> package provides an asynchronous API for interacting with the Evrmore blockchain through the <code>EvrmoreAsyncRPCClient</code> class.</p>"},{"location":"async_api/#installation","title":"Installation","text":"<pre><code>pip install evrmore-rpc\n</code></pre>"},{"location":"async_api/#evrmoreasyncrpcclient","title":"EvrmoreAsyncRPCClient","text":"<p>The <code>EvrmoreAsyncRPCClient</code> class provides an asynchronous, typed interface to the Evrmore RPC API. It allows you to execute multiple RPC commands concurrently, improving performance for applications that need to make many RPC calls.</p>"},{"location":"async_api/#initialization","title":"Initialization","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreAsyncRPCClient\n\n# Create a client with default settings\nclient = EvrmoreAsyncRPCClient()\n\n# Create a client with custom settings\nclient = EvrmoreAsyncRPCClient(\n    datadir=\"/path/to/evrmore/data\",\n    rpcuser=\"username\",\n    rpcpassword=\"password\",\n    rpcport=8819,\n    testnet=False\n)\n</code></pre>"},{"location":"async_api/#parameters","title":"Parameters","text":"<ul> <li><code>datadir</code> (Optional[Path]): Path to Evrmore data directory</li> <li><code>rpcuser</code> (Optional[str]): RPC username</li> <li><code>rpcpassword</code> (Optional[str]): RPC password</li> <li><code>rpcport</code> (Optional[int]): RPC port number</li> <li><code>testnet</code> (bool): Use testnet (default: False)</li> </ul>"},{"location":"async_api/#async-context-manager","title":"Async Context Manager","text":"<p>The <code>EvrmoreAsyncRPCClient</code> class supports the async context manager protocol, which ensures proper cleanup of resources:</p> <pre><code>async def main():\n    async with EvrmoreAsyncRPCClient() as client:\n        # Use the client here\n        info = await client.getblockchaininfo()\n        print(f\"Current block height: {info.blocks}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"async_api/#methods","title":"Methods","text":"<p>The <code>EvrmoreAsyncRPCClient</code> class provides asynchronous methods for all Evrmore RPC commands. These methods are dynamically generated based on the available RPC commands.</p>"},{"location":"async_api/#blockchain-commands","title":"Blockchain Commands","text":"<pre><code>async def main():\n    async with EvrmoreAsyncRPCClient() as client:\n        # Get blockchain info\n        info = await client.getblockchaininfo()\n        print(f\"Current block height: {info.blocks}\")\n        print(f\"Chain: {info.chain}\")\n        print(f\"Difficulty: {info.difficulty}\")\n\n        # Get a block\n        block_hash = await client.getblockhash(1)\n        block = await client.getblock(block_hash)\n        print(f\"Block #1 hash: {block.hash}\")\n        print(f\"Block #1 time: {block.time}\")\n        print(f\"Block #1 transactions: {len(block.tx)}\")\n\n        # Get mempool info\n        mempool_info = await client.getmempoolinfo()\n        print(f\"Mempool size: {mempool_info['size']}\")\n        print(f\"Mempool bytes: {mempool_info['bytes']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"async_api/#asset-commands","title":"Asset Commands","text":"<pre><code>async def main():\n    async with EvrmoreAsyncRPCClient() as client:\n        # List assets\n        assets = await client.listassets()\n        print(f\"Found {len(assets)} assets\")\n\n        # Get asset data\n        asset_info = await client.getassetdata(\"ASSET_NAME\")\n        print(f\"Asset name: {asset_info.name}\")\n        print(f\"Asset amount: {asset_info.amount}\")\n        print(f\"Asset units: {asset_info.units}\")\n        print(f\"Asset reissuable: {asset_info.reissuable}\")\n\n        # Issue a new asset\n        txid = await client.issue(\n            asset_name=\"NEW_ASSET\",\n            qty=1000,\n            to_address=\"EVR_ADDRESS\",\n            change_address=\"EVR_ADDRESS\",\n            units=0,\n            reissuable=True,\n            has_ipfs=False\n        )\n        print(f\"Asset issued with transaction ID: {txid}\")\n\n        # Transfer an asset\n        txid = await client.transfer(\n            asset_name=\"ASSET_NAME\",\n            qty=100,\n            to_address=\"EVR_ADDRESS\"\n        )\n        print(f\"Asset transferred with transaction ID: {txid}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"async_api/#concurrent-execution","title":"Concurrent Execution","text":"<p>One of the main advantages of the asynchronous API is the ability to execute multiple RPC commands concurrently:</p> <pre><code>async def main():\n    async with EvrmoreAsyncRPCClient() as client:\n        # Execute multiple commands concurrently\n        info, block_hash, mempool_info = await asyncio.gather(\n            client.getblockchaininfo(),\n            client.getblockhash(1),\n            client.getmempoolinfo()\n        )\n\n        # Get block details\n        block = await client.getblock(block_hash)\n\n        # Print results\n        print(f\"Current block height: {info.blocks}\")\n        print(f\"Block #1 hash: {block.hash}\")\n        print(f\"Mempool size: {mempool_info['size']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"async_api/#error-handling","title":"Error Handling","text":"<p>The <code>EvrmoreAsyncRPCClient</code> class raises <code>EvrmoreRPCError</code> exceptions when an error occurs:</p> <pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreAsyncRPCClient, EvrmoreRPCError\n\nasync def main():\n    async with EvrmoreAsyncRPCClient() as client:\n        try:\n            result = await client.getblock(\"invalid_hash\")\n        except EvrmoreRPCError as e:\n            print(f\"Error: {e}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"async_api/#direct-command-execution","title":"Direct Command Execution","text":"<p>You can also execute commands directly using the <code>execute_command</code> method:</p> <pre><code>async def main():\n    async with EvrmoreAsyncRPCClient() as client:\n        # Execute a command with arguments\n        result = await client.execute_command(\"getblock\", \"blockhash\", 1)\n        print(result)\n\nasyncio.run(main())\n</code></pre>"},{"location":"async_api/#integration-with-other-async-frameworks","title":"Integration with Other Async Frameworks","text":"<p>The <code>EvrmoreAsyncRPCClient</code> class can be integrated with other async frameworks like FastAPI, aiohttp, or asyncio-based applications:</p>"},{"location":"async_api/#fastapi-example","title":"FastAPI Example","text":"<pre><code>from fastapi import FastAPI, HTTPException\nfrom evrmore_rpc import EvrmoreAsyncRPCClient, EvrmoreRPCError\n\napp = FastAPI()\nclient = EvrmoreAsyncRPCClient()\n\n@app.get(\"/blockchain/info\")\nasync def get_blockchain_info():\n    try:\n        info = await client.getblockchaininfo()\n        return {\n            \"blocks\": info.blocks,\n            \"chain\": info.chain,\n            \"difficulty\": info.difficulty\n        }\n    except EvrmoreRPCError as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/block/{height}\")\nasync def get_block(height: int):\n    try:\n        block_hash = await client.getblockhash(height)\n        block = await client.getblock(block_hash)\n        return {\n            \"hash\": block.hash,\n            \"height\": block.height,\n            \"time\": block.time,\n            \"transactions\": len(block.tx)\n        }\n    except EvrmoreRPCError as e:\n        raise HTTPException(status_code=500, detail=str(e))\n</code></pre>"},{"location":"async_api/#aiohttp-example","title":"aiohttp Example","text":"<p>```python import aiohttp from aiohttp import web from evrmore_rpc import EvrmoreAsyncRPCClient, EvrmoreRPCError</p> <p>async def get_blockchain_info(request):     try:         async with EvrmoreAsyncRPCClient() as client:             info = await client.getblockchaininfo()             return web.json_response({                 \"blocks\": info.blocks,                 \"chain\": info.chain,                 \"difficulty\": info.difficulty             })     except EvrmoreRPCError as e:         return web.json_response({\"error\": str(e)}, status=500)</p> <p>app = web.Application() app.router.add_get('/blockchain/info', get_blockchain_info)</p> <p>if name == 'main':     web.run_app(app) </p>"},{"location":"development/","title":"Development Guide","text":"<p>This guide provides information for developers who want to contribute to the Evrmore RPC library.</p>"},{"location":"development/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<pre><code># Clone the repository\ngit clone https://github.com/ManticoreTechnology/evrmore-rpc.git\ncd evrmore-rpc\n\n# Create a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install development dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"development/#project-structure","title":"Project Structure","text":"<p>The project follows a standard Python package structure:</p> <pre><code>evrmore-rpc/\n\u251c\u2500\u2500 docs/               # Documentation files\n\u251c\u2500\u2500 examples/           # Example scripts\n\u251c\u2500\u2500 scripts/            # Utility scripts\n\u251c\u2500\u2500 src/                # Source code\n\u2502   \u2514\u2500\u2500 evrmore_rpc/    # Main package\n\u2502       \u251c\u2500\u2500 models/     # Data models\n\u2502       \u251c\u2500\u2500 zmq/        # ZMQ client\n\u2502       \u251c\u2500\u2500 __init__.py # Package entry point\n\u2502       \u251c\u2500\u2500 client.py   # Main client implementation\n\u2502       \u251c\u2500\u2500 client.pyi  # Type stub file for IDE support\n\u2502       \u251c\u2500\u2500 config.py   # Configuration handling\n\u2502       \u2514\u2500\u2500 utils.py    # Utility functions\n\u251c\u2500\u2500 tests/              # Test files\n\u251c\u2500\u2500 .gitignore          # Git ignore file\n\u251c\u2500\u2500 LICENSE             # License file\n\u251c\u2500\u2500 MANIFEST.in         # Package manifest\n\u251c\u2500\u2500 mkdocs.yml          # Documentation configuration\n\u251c\u2500\u2500 pyproject.toml      # Project configuration\n\u251c\u2500\u2500 README.md           # Project readme\n\u251c\u2500\u2500 requirements.txt    # Dependencies\n\u2514\u2500\u2500 setup.py            # Setup script\n</code></pre>"},{"location":"development/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run specific tests\npytest tests/test_client.py\n\n# Run tests with coverage\npytest --cov=evrmore_rpc\n</code></pre>"},{"location":"development/#building-documentation","title":"Building Documentation","text":"<pre><code># Build documentation\npython scripts/build_docs.py\n\n# Build and deploy documentation\npython scripts/build_docs.py --deploy\n</code></pre>"},{"location":"development/#running-examples","title":"Running Examples","text":"<pre><code># List available examples\npython scripts/run_examples.py --list\n\n# Run a basic example\npython scripts/run_examples.py super_simple\n\n# Run an advanced example\npython scripts/run_examples.py asset_monitor\n</code></pre>"},{"location":"development/#code-style","title":"Code Style","text":"<p>The project uses the following tools for code style:</p> <ul> <li>Black for code formatting</li> <li>isort for import sorting</li> <li>mypy for type checking</li> </ul> <pre><code># Format code\nblack src tests examples\n\n# Sort imports\nisort src tests examples\n\n# Check types\nmypy src\n</code></pre>"},{"location":"development/#publishing","title":"Publishing","text":"<pre><code># Check readiness for publication\npython scripts/check_publication.py\n\n# Build package\npython -m build\n\n# Upload to PyPI\npython -m twine upload dist/*\n</code></pre>"},{"location":"development/#contribution-guidelines","title":"Contribution Guidelines","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Run tests to ensure they pass</li> <li>Update documentation if needed</li> <li>Submit a pull request</li> </ol> <p>Please follow these guidelines when contributing:</p> <ul> <li>Follow the existing code style</li> <li>Add tests for new features</li> <li>Update documentation for new features</li> <li>Keep commits focused and add descriptive commit messages</li> <li>Rebase your branch before submitting a pull request </li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>The <code>evrmore-rpc</code> package includes several examples demonstrating its functionality. These examples are available in the examples directory of the repository.</p>"},{"location":"examples/#basic-rpc-usage","title":"Basic RPC Usage","text":"<p>The basic RPC usage examples demonstrate how to use the synchronous RPC client to interact with the Evrmore blockchain.</p>"},{"location":"examples/#get-blockchain-info","title":"Get Blockchain Info","text":"<pre><code>from evrmore_rpc import EvrmoreRPCClient\n\n# Create a client\nclient = EvrmoreRPCClient()\n\n# Get blockchain info\ninfo = client.getblockchaininfo()\nprint(f\"Current block height: {info.blocks}\")\nprint(f\"Chain: {info.chain}\")\nprint(f\"Difficulty: {info.difficulty}\")\n</code></pre>"},{"location":"examples/#get-block-data","title":"Get Block Data","text":"<pre><code>from evrmore_rpc import EvrmoreRPCClient\n\n# Create a client\nclient = EvrmoreRPCClient()\n\n# Get a block\nblock_hash = client.getblockhash(1)\nblock = client.getblock(block_hash)\nprint(f\"Block #1 hash: {block.hash}\")\nprint(f\"Block #1 time: {block.time}\")\nprint(f\"Block #1 transactions: {len(block.tx)}\")\n</code></pre>"},{"location":"examples/#list-assets","title":"List Assets","text":"<pre><code>from evrmore_rpc import EvrmoreRPCClient\n\n# Create a client\nclient = EvrmoreRPCClient()\n\n# List assets\nassets = client.listassets()\nprint(f\"Found {len(assets)} assets\")\n\n# List my assets\nmy_assets = client.listmyassets()\nprint(f\"Found {len(my_assets)} assets in my wallet\")\n</code></pre>"},{"location":"examples/#asynchronous-rpc-usage","title":"Asynchronous RPC Usage","text":"<p>The asynchronous RPC usage examples demonstrate how to use the asynchronous RPC client to interact with the Evrmore blockchain.</p>"},{"location":"examples/#get-blockchain-info_1","title":"Get Blockchain Info","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreAsyncRPCClient\n\nasync def main():\n    # Create a client\n    async with EvrmoreAsyncRPCClient() as client:\n        # Get blockchain info\n        info = await client.getblockchaininfo()\n        print(f\"Current block height: {info.blocks}\")\n        print(f\"Chain: {info.chain}\")\n        print(f\"Difficulty: {info.difficulty}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#concurrent-execution","title":"Concurrent Execution","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreAsyncRPCClient\n\nasync def main():\n    # Create a client\n    async with EvrmoreAsyncRPCClient() as client:\n        # Execute multiple commands concurrently\n        info, block_hash, mempool_info = await asyncio.gather(\n            client.getblockchaininfo(),\n            client.getblockhash(1),\n            client.getmempoolinfo()\n        )\n\n        # Get block details\n        block = await client.getblock(block_hash)\n\n        # Print results\n        print(f\"Current block height: {info.blocks}\")\n        print(f\"Block #1 hash: {block.hash}\")\n        print(f\"Mempool size: {mempool_info['size']}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#zmq-notifications","title":"ZMQ Notifications","text":"<p>The ZMQ notifications examples demonstrate how to use the ZMQ client to receive real-time notifications from the Evrmore blockchain.</p>"},{"location":"examples/#block-and-transaction-notifications","title":"Block and Transaction Notifications","text":"<pre><code>import asyncio\nfrom evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\nasync def handle_block(notification):\n    print(f\"New block: {notification.hex}\")\n\nasync def handle_transaction(notification):\n    print(f\"New transaction: {notification.hex}\")\n\nasync def main():\n    # Create a ZMQ client\n    client = EvrmoreZMQClient(\n        address=\"tcp://127.0.0.1:28332\",\n        topics=[ZMQTopic.HASH_BLOCK, ZMQTopic.HASH_TX]\n    )\n\n    # Register handlers\n    client.on_block(handle_block)\n    client.on_transaction(handle_transaction)\n\n    # Start the client\n    await client.start()\n\n    # Keep running until interrupted\n    try:\n        while True:\n            await asyncio.sleep(1)\n    finally:\n        await client.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#transaction-analysis","title":"Transaction Analysis","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreRPCClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\nasync def handle_transaction(notification):\n    txid = notification.hex\n    print(f\"New transaction: {txid}\")\n\n    # Get transaction details\n    client = EvrmoreRPCClient()\n    tx = client.getrawtransaction(txid, True)\n\n    # Analyze transaction\n    print(f\"Transaction size: {tx.size} bytes\")\n    print(f\"Transaction inputs: {len(tx.vin)}\")\n    print(f\"Transaction outputs: {len(tx.vout)}\")\n\n    # Check for asset transfers\n    for vout in tx.vout:\n        if \"asset\" in vout.get(\"scriptPubKey\", {}).get(\"asset\", {}):\n            asset = vout[\"scriptPubKey\"][\"asset\"]\n            print(f\"Asset transfer: {asset['name']} ({asset['amount']})\")\n\nasync def main():\n    # Create a ZMQ client\n    client = EvrmoreZMQClient(\n        address=\"tcp://127.0.0.1:28332\",\n        topics=[ZMQTopic.HASH_TX]\n    )\n\n    # Register handler\n    client.on_transaction(handle_transaction)\n\n    # Start the client\n    await client.start()\n\n    # Keep running until interrupted\n    try:\n        while True:\n            await asyncio.sleep(1)\n    finally:\n        await client.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#websockets-support","title":"WebSockets Support","text":"<p>The WebSockets examples demonstrate how to use the WebSockets client and server to receive real-time notifications from the Evrmore blockchain.</p>"},{"location":"examples/#websocket-client","title":"WebSocket Client","text":"<pre><code>import asyncio\nfrom evrmore_rpc.websockets import EvrmoreWebSocketClient\n\nasync def main():\n    # Create a WebSocket client\n    client = EvrmoreWebSocketClient(uri=\"ws://localhost:8765\")\n\n    # Connect to the WebSocket server\n    await client.connect()\n\n    # Subscribe to block and transaction notifications\n    await client.subscribe(\"blocks\")\n    await client.subscribe(\"transactions\")\n\n    # Process incoming messages\n    async for message in client:\n        if message.type == \"block\":\n            block_data = message.data\n            print(f\"New block: {block_data.hash} (height: {block_data.height})\")\n\n        elif message.type == \"transaction\":\n            tx_data = message.data\n            print(f\"New transaction: {tx_data.txid}\")\n\n    # Disconnect\n    await client.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#websocket-server","title":"WebSocket Server","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreRPCClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient\nfrom evrmore_rpc.websockets import EvrmoreWebSocketServer\n\nasync def main():\n    # Create RPC client\n    rpc_client = EvrmoreRPCClient()\n\n    # Create ZMQ client\n    zmq_client = EvrmoreZMQClient(\n        address=\"tcp://127.0.0.1:28332\"\n    )\n\n    # Create WebSocket server\n    server = EvrmoreWebSocketServer(\n        rpc_client=rpc_client,\n        zmq_client=zmq_client,\n        host=\"localhost\",\n        port=8765\n    )\n\n    # Start the server\n    await server.start()\n    print(f\"WebSocket server started on ws://{server.host}:{server.port}\")\n\n    # Keep the server running until interrupted\n    try:\n        while True:\n            await asyncio.sleep(1)\n    finally:\n        # Stop the server\n        await server.stop()\n        print(\"WebSocket server stopped\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#asset-swap-platform","title":"Asset Swap Platform","text":"<p>The asset swap platform example demonstrates how to build a decentralized exchange for Evrmore assets using the <code>evrmore-rpc</code> package.</p>"},{"location":"examples/#simple-swap","title":"Simple Swap","text":"<pre><code>import asyncio\nfrom decimal import Decimal\nfrom evrmore_rpc import EvrmoreRPCClient\n\nclass AssetSwap:\n    def __init__(self):\n        self.client = EvrmoreRPCClient()\n\n    def list_my_assets(self):\n        \"\"\"List assets in my wallet.\"\"\"\n        assets = self.client.listmyassets()\n        return assets\n\n    def create_swap_offer(self, asset_offered, amount_offered, asset_wanted, amount_wanted):\n        \"\"\"Create a swap offer.\"\"\"\n        # In a real implementation, this would create a transaction or smart contract\n        print(f\"Creating swap offer: {amount_offered} {asset_offered} for {amount_wanted} {asset_wanted}\")\n\n    def execute_swap(self, offer_id):\n        \"\"\"Execute a swap offer.\"\"\"\n        # In a real implementation, this would execute the transaction or smart contract\n        print(f\"Executing swap offer {offer_id}\")\n\nasync def main():\n    swap = AssetSwap()\n\n    # List my assets\n    assets = swap.list_my_assets()\n    print(\"My assets:\")\n    for asset, amount in assets.items():\n        print(f\"  {asset}: {amount}\")\n\n    # Create a swap offer\n    swap.create_swap_offer(\"ASSET_A\", Decimal(\"10\"), \"ASSET_B\", Decimal(\"20\"))\n\n    # Execute a swap offer\n    swap.execute_swap(\"offer_id\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#real-time-swap","title":"Real-time Swap","text":"<pre><code>import asyncio\nimport json\nfrom decimal import Decimal\nfrom evrmore_rpc import EvrmoreRPCClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient\n\nclass RealTimeAssetSwap:\n    def __init__(self):\n        self.rpc_client = EvrmoreRPCClient()\n        self.zmq_client = EvrmoreZMQClient()\n        self.offers = []\n\n    async def start(self):\n        \"\"\"Start the swap platform.\"\"\"\n        # Register ZMQ handlers\n        self.zmq_client.on_transaction(self.handle_transaction)\n\n        # Start ZMQ client\n        await self.zmq_client.start()\n\n    async def stop(self):\n        \"\"\"Stop the swap platform.\"\"\"\n        await self.zmq_client.stop()\n\n    async def handle_transaction(self, notification):\n        \"\"\"Handle a new transaction.\"\"\"\n        txid = notification.hex\n        print(f\"New transaction: {txid}\")\n\n        # Get transaction details\n        tx = self.rpc_client.getrawtransaction(txid, True)\n\n        # Check for asset transfers\n        for vout in tx.vout:\n            if \"asset\" in vout.get(\"scriptPubKey\", {}).get(\"asset\", {}):\n                asset = vout[\"scriptPubKey\"][\"asset\"]\n                print(f\"Asset transfer: {asset['name']} ({asset['amount']})\")\n\n                # Check if this transfer matches any of our offers\n                self.check_for_matching_offers(asset[\"name\"], Decimal(str(asset[\"amount\"])))\n\n    def check_for_matching_offers(self, asset_name, amount):\n        \"\"\"Check if an asset transfer matches any of our offers.\"\"\"\n        for offer in self.offers:\n            if offer[\"status\"] == \"open\" and offer[\"asset_wanted\"] == asset_name and offer[\"amount_wanted\"] == amount:\n                print(f\"Found matching offer: {offer['id']}\")\n\n                # Execute the swap\n                self.execute_swap(offer[\"id\"])\n\n    def create_swap_offer(self, asset_offered, amount_offered, asset_wanted, amount_wanted):\n        \"\"\"Create a swap offer.\"\"\"\n        offer_id = f\"offer_{len(self.offers)}\"\n        offer = {\n            \"id\": offer_id,\n            \"asset_offered\": asset_offered,\n            \"amount_offered\": amount_offered,\n            \"asset_wanted\": asset_wanted,\n            \"amount_wanted\": amount_wanted,\n            \"status\": \"open\"\n        }\n        self.offers.append(offer)\n        print(f\"Created swap offer: {offer_id}\")\n        return offer_id\n\n    def execute_swap(self, offer_id):\n        \"\"\"Execute a swap offer.\"\"\"\n        for offer in self.offers:\n            if offer[\"id\"] == offer_id and offer[\"status\"] == \"open\":\n                print(f\"Executing swap offer: {offer_id}\")\n\n                # In a real implementation, this would execute the transaction\n                offer[\"status\"] = \"completed\"\n                print(f\"Swap offer {offer_id} completed\")\n                return True\n\n        print(f\"Swap offer {offer_id} not found or not open\")\n        return False\n\nasync def main():\n    swap = RealTimeAssetSwap()\n\n    # Start the swap platform\n    await swap.start()\n\n    # Create a swap offer\n    offer_id = swap.create_swap_offer(\"ASSET_A\", Decimal(\"10\"), \"ASSET_B\", Decimal(\"20\"))\n\n    # Keep running until interrupted\n    try:\n        while True:\n            await asyncio.sleep(1)\n    finally:\n        await swap.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#balance-tracker","title":"Balance Tracker","text":"<p>The balance tracker example demonstrates how to track asset balances in real-time using the <code>evrmore-rpc</code> package.</p> <pre><code>import asyncio\nfrom decimal import Decimal\nfrom evrmore_rpc import EvrmoreRPCClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient\n\nclass BalanceTracker:\n    def __init__(self):\n        self.rpc_client = EvrmoreRPCClient()\n        self.zmq_client = EvrmoreZMQClient()\n        self.balances = {}\n        self.addresses = []\n\n    async def start(self):\n        \"\"\"Start the balance tracker.\"\"\"\n        # Register ZMQ handlers\n        self.zmq_client.on_transaction(self.handle_transaction)\n\n        # Start ZMQ client\n        await self.zmq_client.start()\n\n    async def stop(self):\n        \"\"\"Stop the balance tracker.\"\"\"\n        await self.zmq_client.stop()\n\n    def add_address(self, address):\n        \"\"\"Add an address to track.\"\"\"\n        self.addresses.append(address)\n\n        # Get current balances\n        balances = self.rpc_client.getaddressbalance({\"addresses\": [address]})\n\n        # Store balances\n        self.balances[address] = {\n            \"EVR\": Decimal(str(balances[\"balance\"] / 100000000)),\n            \"assets\": {}\n        }\n\n        # Get asset balances\n        assets = self.rpc_client.getaddressutxos({\"addresses\": [address]})\n        for utxo in assets:\n            if \"asset\" in utxo:\n                asset_name = utxo[\"asset\"][\"name\"]\n                asset_amount = Decimal(str(utxo[\"asset\"][\"amount\"]))\n\n                if asset_name in self.balances[address][\"assets\"]:\n                    self.balances[address][\"assets\"][asset_name] += asset_amount\n                else:\n                    self.balances[address][\"assets\"][asset_name] = asset_amount\n\n        print(f\"Added address: {address}\")\n        print(f\"  EVR balance: {self.balances[address]['EVR']}\")\n        print(f\"  Asset balances: {self.balances[address]['assets']}\")\n\n    async def handle_transaction(self, notification):\n        \"\"\"Handle a new transaction.\"\"\"\n        txid = notification.hex\n\n        # Get transaction details\n        tx = self.rpc_client.getrawtransaction(txid, True)\n\n        # Check for transfers to/from tracked addresses\n        for vout in tx.vout:\n            if \"addresses\" in vout.get(\"scriptPubKey\", {}):\n                for address in vout[\"scriptPubKey\"][\"addresses\"]:\n                    if address in self.addresses:\n                        # Update EVR balance\n                        amount = Decimal(str(vout[\"value\"]))\n                        self.balances[address][\"EVR\"] += amount\n                        print(f\"Updated EVR balance for {address}: {self.balances[address]['EVR']}\")\n\n                        # Update asset balance\n                        if \"asset\" in vout.get(\"scriptPubKey\", {}):\n                            asset = vout[\"scriptPubKey\"][\"asset\"]\n                            asset_name = asset[\"name\"]\n                            asset_amount = Decimal(str(asset[\"amount\"]))\n\n                            if asset_name in self.balances[address][\"assets\"]:\n                                self.balances[address][\"assets\"][asset_name] += asset_amount\n                            else:\n                                self.balances[address][\"assets\"][asset_name] = asset_amount\n\n                            print(f\"Updated asset balance for {address}: {asset_name} = {self.balances[address]['assets'][asset_name]}\")\n\n        # Check for transfers from tracked addresses\n        for vin in tx.vin:\n            if \"txid\" in vin and \"vout\" in vin:\n                prev_tx = self.rpc_client.getrawtransaction(vin[\"txid\"], True)\n                prev_vout = prev_tx.vout[vin[\"vout\"]]\n\n                if \"addresses\" in prev_vout.get(\"scriptPubKey\", {}):\n                    for address in prev_vout[\"scriptPubKey\"][\"addresses\"]:\n                        if address in self.addresses:\n                            # Update EVR balance\n                            amount = Decimal(str(prev_vout[\"value\"]))\n                            self.balances[address][\"EVR\"] -= amount\n                            print(f\"Updated EVR balance for {address}: {self.balances[address]['EVR']}\")\n\n                            # Update asset balance\n                            if \"asset\" in prev_vout.get(\"scriptPubKey\", {}):\n                                asset = prev_vout[\"scriptPubKey\"][\"asset\"]\n                                asset_name = asset[\"name\"]\n                                asset_amount = Decimal(str(asset[\"amount\"]))\n\n                                if asset_name in self.balances[address][\"assets\"]:\n                                    self.balances[address][\"assets\"][asset_name] -= asset_amount\n                                    print(f\"Updated asset balance for {address}: {asset_name} = {self.balances[address]['assets'][asset_name]}\")\n\nasync def main():\n    tracker = BalanceTracker()\n\n    # Start the balance tracker\n    await tracker.start()\n\n    # Add addresses to track\n    tracker.add_address(\"EVRxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\")\n    tracker.add_address(\"EVRyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\")\n\n    # Keep running until interrupted\n    try:\n        while True:\n            await asyncio.sleep(1)\n    finally:\n        await tracker.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#interactive-dashboard","title":"Interactive Dashboard","text":"<p>The interactive dashboard example demonstrates how to build a real-time dashboard for monitoring the Evrmore blockchain using the <code>evrmore-rpc</code> package.</p> <p>```python import asyncio import datetime from rich.console import Console from rich.table import Table from rich.panel import Panel from rich.layout import Layout from rich.live import Live from evrmore_rpc import EvrmoreRPCClient from evrmore_rpc.zmq import EvrmoreZMQClient</p> <p>class EvrmoreMonitor:     def init(self):         self.rpc_client = EvrmoreRPCClient()         self.zmq_client = EvrmoreZMQClient()         self.console = Console()         self.layout = Layout()         self.recent_blocks = []         self.recent_transactions = []         self.mempool_stats = {\"size\": 0, \"bytes\": 0, \"usage\": 0}         self.network_stats = {\"connections\": 0, \"version\": \"\", \"subversion\": \"\", \"protocolversion\": 0}         self.blockchain_stats = {\"blocks\": 0, \"headers\": 0, \"difficulty\": 0, \"chain\": \"\"}</p> <pre><code>async def start(self):\n    \"\"\"Start the monitor.\"\"\"\n    # Register ZMQ handlers\n    self.zmq_client.on_block(self.handle_block)\n    self.zmq_client.on_transaction(self.handle_transaction)\n\n    # Start ZMQ client\n    await self.zmq_client.start()\n\n    # Initialize data\n    await self.update_blockchain_stats()\n    await self.update_network_stats()\n    await self.update_mempool_stats()\n    await self.update_recent_blocks()\n\nasync def stop(self):\n    \"\"\"Stop the monitor.\"\"\"\n    await self.zmq_client.stop()\n\nasync def handle_block(self, notification):\n    \"\"\"Handle a new block.\"\"\"\n    block_hash = notification.hex\n\n    # Get block details\n    block = self.rpc_client.getblock(block_hash)\n\n    # Add to recent blocks\n    self.recent_blocks.insert(0, {\n        \"hash\": block.hash,\n        \"height\": block.height,\n        \"time\": datetime.datetime.fromtimestamp(block.time),\n        \"txs\": len(block.tx),\n        \"size\": block.size\n    })\n\n    # Keep only the 10 most recent blocks\n    self.recent_blocks = self.recent_blocks[:10]\n\n    # Update stats\n    await self.update_blockchain_stats()\n    await self.update_mempool_stats()\n\nasync def handle_transaction(self, notification):\n    \"\"\"Handle a new transaction.\"\"\"\n    txid = notification.hex\n\n    # Get transaction details\n    try:\n        tx = self.rpc_client.getrawtransaction(txid, True)\n\n        # Add to recent transactions\n        self.recent_transactions.insert(0, {\n            \"txid\": tx.txid,\n            \"size\": tx.size,\n            \"vsize\": tx.vsize,\n            \"time\": datetime.datetime.now(),\n            \"inputs\": len(tx.vin),\n            \"outputs\": len(tx.vout)\n        })\n\n        # Keep only the 10 most recent transactions\n        self.recent_transactions = self.recent_transactions[:10]\n\n        # Update mempool stats\n        await self.update_mempool_stats()\n    except:\n        # Transaction might not be in mempool yet\n        pass\n\nasync def update_blockchain_stats(self):\n    \"\"\"Update blockchain statistics.\"\"\"\n    info = self.rpc_client.getblockchaininfo()\n    self.blockchain_stats = {\n        \"blocks\": info.blocks,\n        \"headers\": info.headers,\n        \"difficulty\": info.difficulty,\n        \"chain\": info.chain\n    }\n\nasync def update_network_stats(self):\n    \"\"\"Update network statistics.\"\"\"\n    info = self.rpc_client.getnetworkinfo()\n    self.network_stats = {\n        \"connections\": info.connections,\n        \"version\": info.version,\n        \"subversion\": info.subversion,\n        \"protocolversion\": info.protocolversion\n    }\n\nasync def update_mempool_stats(self):\n    \"\"\"Update mempool statistics.\"\"\"\n    info = self.rpc_client.getmempoolinfo()\n    self.mempool_stats = {\n        \"size\": info[\"size\"],\n        \"bytes\": info[\"bytes\"],\n        \"usage\": info[\"usage\"]\n    }\n\nasync def update_recent_blocks(self):\n    \"\"\"Update recent blocks.\"\"\"\n    # Get current block height\n    height = self.rpc_client.getblockcount()\n\n    # Get the 10 most recent blocks\n    for i in range(height, max(0, height - 10), -1):\n        block_hash = self.rpc_client.getblockhash(i)\n        block = self.rpc_client.getblock(block_hash)\n\n        self.recent_blocks.append({\n            \"hash\": block.hash,\n            \"height\": block.height,\n            \"time\": datetime.datetime.fromtimestamp(block.time),\n            \"txs\": len(block.tx),\n            \"size\": block.size\n        })\n\ndef render_dashboard(self):\n    \"\"\"Render the dashboard.\"\"\"\n    self.layout.split(\n        Layout(name=\"header\", size=3),\n        Layout(name=\"main\"),\n        Layout(name=\"footer\", size=3)\n    )\n\n    self.layout[\"main\"].split_row(\n        Layout(name=\"left\"),\n        Layout(name=\"right\")\n    )\n\n    self.layout[\"left\"].split(\n        Layout(name=\"blockchain\", size=10),\n        Layout(name=\"blocks\")\n    )\n\n    self.layout[\"right\"].split(\n        Layout(name=\"network\", size=10),\n        Layout(name=\"mempool\", size=10),\n        Layout(name=\"transactions\")\n    )\n\n    # Header\n    self.layout[\"header\"].update(\n        Panel(\n            f\"Evrmore Blockchain Monitor - {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\",\n            style=\"bold white on blue\"\n        )\n    )\n\n    # Blockchain stats\n    blockchain_table = Table(title=\"Blockchain Stats\")\n    blockchain_table.add_column(\"Stat\")\n    blockchain_table.add_column(\"Value\")\n    blockchain_table.add_row(\"Chain\", self.blockchain_stats[\"chain\"])\n    blockchain_table.add_row(\"Blocks\", str(self.blockchain_stats[\"blocks\"]))\n    blockchain_table.add_row(\"Headers\", str(self.blockchain_stats[\"headers\"]))\n    blockchain_table.add_row(\"Difficulty\", f\"{self.blockchain_stats['difficulty']:.8f}\")\n    self.layout[\"blockchain\"].update(blockchain_table)\n\n    # Network stats\n    network_table = Table(title=\"Network Stats\")\n    network_table.add_column(\"Stat\")\n    network_table.add_column(\"Value\")\n    network_table.add_row(\"Connections\", str(self.network_stats[\"connections\"]))\n    network_table.add_row(\"Version\", str(self.network_stats[\"version\"]))\n    network_table.add_row(\"Subversion\", self.network_stats[\"subversion\"])\n    network_table.add_row(\"Protocol\", str(self.network_stats[\"protocolversion\"]))\n    self.layout[\"network\"].update(network_table)\n\n    # Mempool stats\n    mempool_table = Table(title=\"Mempool Stats\")\n    mempool_table.add_column(\"Stat\")\n    mempool_table.add_column(\"Value\")\n    mempool_table.add_row(\"Transactions\", str(self.mempool_stats[\"size\"]))\n    mempool_table.add_row(\"Size\", f\"{self.mempool_stats['bytes'] / 1024 / 1024:.2f} MB\")\n    mempool_table.add_row(\"Memory Usage\", f\"{self.mempool_stats['usage'] / 1024 / 1024:.2f} MB\")\n    self.layout[\"mempool\"].update(mempool_table)\n\n    # Recent blocks\n    blocks_table = Table(title=\"Recent Blocks\")\n    blocks_table.add_column(\"Height\")\n    blocks_table.add_column(\"Hash\")\n    blocks_table.add_column(\"Time\")\n    blocks_table.add_column(\"Txs\")\n    blocks_table.add_column(\"Size\")\n\n    for block in self.recent_blocks:\n        blocks_table.add_row(\n            str(block[\"height\"]),\n            block[\"hash\"][:10] + \"...\",\n            block[\"time\"].strftime(\"%H:%M:%S\"),\n            str(block[\"txs\"]),\n            f\"{block['size'] / 1024:.2f} KB\"\n        )\n\n    self.layout[\"blocks\"].update(blocks_table)\n\n    # Recent transactions\n    txs_table = Table(title=\"Recent Transactions\")\n    txs_table.add_column(\"TxID\")\n    txs_table.add_column(\"Time\")\n    txs_table.add_column(\"Size\")\n    txs_table.add_column(\"Inputs\")\n    txs_table.add_column(\"Outputs\")\n\n    for tx in self.recent_transactions:\n        txs_table.add_row(\n            tx[\"txid\"][:10] + \"...\",\n            tx[\"time\"].strftime(\"%H:%M:%S\"),\n            f\"{tx['size']} bytes\",\n            str(tx[\"inputs\"]),\n            str(tx[\"outputs\"])\n        )\n\n    self.layout[\"transactions\"].update(txs_table)\n\n    # Footer\n    self.layout[\"footer\"].update(\n        Panel(\n            \"Press Ctrl+C to exit\",\n            style=\"bold white on blue\"\n        )\n    )\n\n    return self.layout\n</code></pre> <p>async def main():     monitor = EvrmoreMonitor()</p> <pre><code># Start the monitor\nawait monitor.start()\n\n# Create a live display\nwith Live(monitor.render_dashboard(), refresh_per_second=1) as live:\n    try:\n        while True:\n            # Update the display\n            live.update(monitor.render_dashboard())\n\n            # Wait a bit\n            await asyncio.sleep(1)\n    finally:\n        await monitor.stop()\n</code></pre> <p>if name == \"main\":     asyncio.run(main()) </p>"},{"location":"models/","title":"Data Models","text":"<p>The <code>evrmore-rpc</code> package provides a set of data models for working with Evrmore blockchain data. These models are implemented using Pydantic, which provides data validation, serialization, and documentation features.</p>"},{"location":"models/#base-models","title":"Base Models","text":"<p>The base models are defined in the <code>evrmore_rpc.models.base</code> module.</p>"},{"location":"models/#amount","title":"Amount","text":"<p>The <code>Amount</code> model represents a monetary amount in the Evrmore blockchain.</p> <pre><code>from evrmore_rpc.models.base import Amount\n\n# Create an amount\namount = Amount(value=1.23456789)\n\n# Access properties\nprint(amount.value)  # 1.23456789\nprint(float(amount))  # 1.23456789\nprint(str(amount))  # \"1.23456789\"\n</code></pre>"},{"location":"models/#address","title":"Address","text":"<p>The <code>Address</code> model represents an Evrmore address.</p> <pre><code>from evrmore_rpc.models.base import Address\n\n# Create an address\naddress = Address(value=\"EVRxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\")\n\n# Access properties\nprint(address.value)  # \"EVRxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\nprint(str(address))  # \"EVRxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n</code></pre>"},{"location":"models/#asset","title":"Asset","text":"<p>The <code>Asset</code> model represents an Evrmore asset.</p> <pre><code>from evrmore_rpc.models.base import Asset\n\n# Create an asset\nasset = Asset(\n    name=\"ASSET_NAME\",\n    amount=1000,\n    units=0,\n    reissuable=True,\n    has_ipfs=False\n)\n\n# Access properties\nprint(asset.name)  # \"ASSET_NAME\"\nprint(asset.amount)  # 1000\nprint(asset.units)  # 0\nprint(asset.reissuable)  # True\nprint(asset.has_ipfs)  # False\n</code></pre>"},{"location":"models/#transaction","title":"Transaction","text":"<p>The <code>Transaction</code> model represents a transaction in the Evrmore blockchain.</p> <pre><code>from evrmore_rpc.models.base import Transaction\n\n# Create a transaction\ntransaction = Transaction(\n    txid=\"txid\",\n    hash=\"hash\",\n    version=1,\n    size=225,\n    vsize=225,\n    weight=900,\n    locktime=0,\n    vin=[...],\n    vout=[...],\n    hex=\"hex\",\n    blockhash=\"blockhash\",\n    confirmations=1,\n    time=1234567890,\n    blocktime=1234567890\n)\n\n# Access properties\nprint(transaction.txid)  # \"txid\"\nprint(transaction.hash)  # \"hash\"\nprint(transaction.confirmations)  # 1\n</code></pre>"},{"location":"models/#block","title":"Block","text":"<p>The <code>Block</code> model represents a block in the Evrmore blockchain.</p> <pre><code>from evrmore_rpc.models.base import Block\n\n# Create a block\nblock = Block(\n    hash=\"hash\",\n    confirmations=1,\n    size=1234,\n    strippedsize=1234,\n    weight=4936,\n    height=123456,\n    version=536870912,\n    versionHex=\"20000000\",\n    merkleroot=\"merkleroot\",\n    tx=[\"txid1\", \"txid2\"],\n    time=1234567890,\n    mediantime=1234567890,\n    nonce=1234567890,\n    bits=\"1d00ffff\",\n    difficulty=1.23456789,\n    chainwork=\"chainwork\",\n    previousblockhash=\"previousblockhash\",\n    nextblockhash=\"nextblockhash\"\n)\n\n# Access properties\nprint(block.hash)  # \"hash\"\nprint(block.height)  # 123456\nprint(block.time)  # 1234567890\nprint(len(block.tx))  # 2\n</code></pre>"},{"location":"models/#rpcresponse","title":"RPCResponse","text":"<p>The <code>RPCResponse</code> model represents a response from the Evrmore RPC API.</p> <pre><code>from evrmore_rpc.models.base import RPCResponse\n\n# Create a response\nresponse = RPCResponse(\n    result={\"key\": \"value\"},\n    error=None,\n    id=\"1\"\n)\n\n# Access properties\nprint(response.result)  # {\"key\": \"value\"}\nprint(response.error)  # None\nprint(response.id)  # \"1\"\n</code></pre>"},{"location":"models/#blockchain-models","title":"Blockchain Models","text":"<p>The blockchain models are defined in the <code>evrmore_rpc.commands.blockchain</code> module.</p>"},{"location":"models/#blockchaininfo","title":"BlockchainInfo","text":"<p>The <code>BlockchainInfo</code> model represents information about the blockchain.</p> <pre><code>from evrmore_rpc.commands.blockchain import BlockchainInfo\n\n# Create blockchain info\ninfo = BlockchainInfo(\n    chain=\"main\",\n    blocks=123456,\n    headers=123456,\n    bestblockhash=\"hash\",\n    difficulty=1.23456789,\n    mediantime=1234567890,\n    verificationprogress=1.0,\n    initialblockdownload=False,\n    chainwork=\"chainwork\",\n    size_on_disk=1234567890,\n    pruned=False,\n    softforks={},\n    bip9_softforks={}\n)\n\n# Access properties\nprint(info.chain)  # \"main\"\nprint(info.blocks)  # 123456\nprint(info.difficulty)  # 1.23456789\n</code></pre>"},{"location":"models/#blockheader","title":"BlockHeader","text":"<p>The <code>BlockHeader</code> model represents a block header.</p> <pre><code>from evrmore_rpc.commands.blockchain import BlockHeader\n\n# Create a block header\nheader = BlockHeader(\n    hash=\"hash\",\n    confirmations=1,\n    height=123456,\n    version=536870912,\n    versionHex=\"20000000\",\n    merkleroot=\"merkleroot\",\n    time=1234567890,\n    mediantime=1234567890,\n    nonce=1234567890,\n    bits=\"1d00ffff\",\n    difficulty=1.23456789,\n    chainwork=\"chainwork\",\n    previousblockhash=\"previousblockhash\",\n    nextblockhash=\"nextblockhash\"\n)\n\n# Access properties\nprint(header.hash)  # \"hash\"\nprint(header.height)  # 123456\nprint(header.time)  # 1234567890\n</code></pre>"},{"location":"models/#asset-models","title":"Asset Models","text":"<p>The asset models are defined in the <code>evrmore_rpc.commands.assets</code> module.</p>"},{"location":"models/#assetinfo","title":"AssetInfo","text":"<p>The <code>AssetInfo</code> model represents information about an asset.</p> <pre><code>from evrmore_rpc.commands.assets import AssetInfo\n\n# Create asset info\ninfo = AssetInfo(\n    name=\"ASSET_NAME\",\n    amount=1000,\n    units=0,\n    reissuable=True,\n    has_ipfs=False,\n    block_height=123456,\n    blockhash=\"blockhash\",\n    txid=\"txid\",\n    vout=0,\n    divisibility=0,\n    locked=False,\n    ipfs_hash=\"\"\n)\n\n# Access properties\nprint(info.name)  # \"ASSET_NAME\"\nprint(info.amount)  # 1000\nprint(info.units)  # 0\nprint(info.reissuable)  # True\n</code></pre>"},{"location":"models/#listassetsresult","title":"ListAssetsResult","text":"<p>The <code>ListAssetsResult</code> model represents the result of the <code>listassets</code> command.</p> <pre><code>from evrmore_rpc.commands.assets import ListAssetsResult, AssetInfo\n\n# Create a list assets result\nresult = ListAssetsResult(\n    assets={\n        \"ASSET_1\": AssetInfo(...),\n        \"ASSET_2\": AssetInfo(...)\n    },\n    count=2\n)\n\n# Access properties\nprint(result.count)  # 2\nprint(len(result.assets))  # 2\nprint(result.assets[\"ASSET_1\"].name)  # \"ASSET_1\"\n</code></pre>"},{"location":"models/#network-models","title":"Network Models","text":"<p>The network models are defined in the <code>evrmore_rpc.commands.network</code> module.</p>"},{"location":"models/#networkinfo","title":"NetworkInfo","text":"<p>The <code>NetworkInfo</code> model represents information about the network.</p> <pre><code>from evrmore_rpc.commands.network import NetworkInfo\n\n# Create network info\ninfo = NetworkInfo(\n    version=1234567,\n    subversion=\"/Evrmore:1.2.3/\",\n    protocolversion=70016,\n    localservices=\"000000000000040d\",\n    localrelay=True,\n    timeoffset=0,\n    connections=8,\n    networkactive=True,\n    networks=[...],\n    relayfee=0.00001,\n    incrementalfee=0.00001,\n    localaddresses=[...],\n    warnings=\"\"\n)\n\n# Access properties\nprint(info.version)  # 1234567\nprint(info.subversion)  # \"/Evrmore:1.2.3/\"\nprint(info.connections)  # 8\n</code></pre>"},{"location":"models/#peerinfo","title":"PeerInfo","text":"<p>The <code>PeerInfo</code> model represents information about a peer.</p> <pre><code>from evrmore_rpc.commands.network import PeerInfo\n\n# Create peer info\ninfo = PeerInfo(\n    id=1,\n    addr=\"127.0.0.1:8819\",\n    addrbind=\"127.0.0.1:8819\",\n    addrlocal=\"127.0.0.1:8819\",\n    services=\"000000000000040d\",\n    relaytxes=True,\n    lastsend=1234567890,\n    lastrecv=1234567890,\n    bytessent=1234,\n    bytesrecv=1234,\n    conntime=1234567890,\n    timeoffset=0,\n    pingtime=0.123,\n    minping=0.123,\n    version=70016,\n    subver=\"/Evrmore:1.2.3/\",\n    inbound=False,\n    addnode=False,\n    startingheight=123456,\n    banscore=0,\n    synced_headers=123456,\n    synced_blocks=123456,\n    inflight=[],\n    whitelisted=False,\n    permissions=[],\n    minfeefilter=0.00001\n)\n\n# Access properties\nprint(info.id)  # 1\nprint(info.addr)  # \"127.0.0.1:8819\"\nprint(info.version)  # 70016\n</code></pre>"},{"location":"models/#mining-models","title":"Mining Models","text":"<p>The mining models are defined in the <code>evrmore_rpc.commands.mining</code> module.</p>"},{"location":"models/#mininginfo","title":"MiningInfo","text":"<p>The <code>MiningInfo</code> model represents information about mining.</p> <pre><code>from evrmore_rpc.commands.mining import MiningInfo\n\n# Create mining info\ninfo = MiningInfo(\n    blocks=123456,\n    currentblockweight=4000,\n    currentblocktx=100,\n    difficulty=1.23456789,\n    networkhashps=1234567890,\n    pooledtx=100,\n    chain=\"main\",\n    warnings=\"\"\n)\n\n# Access properties\nprint(info.blocks)  # 123456\nprint(info.difficulty)  # 1.23456789\nprint(info.networkhashps)  # 1234567890\n</code></pre>"},{"location":"models/#utility-models","title":"Utility Models","text":"<p>The utility models are defined in the <code>evrmore_rpc.commands.util</code> module.</p>"},{"location":"models/#utilinfo","title":"UtilInfo","text":"<p>The <code>UtilInfo</code> model represents utility information.</p> <pre><code>from evrmore_rpc.commands.util import UtilInfo\n\n# Create utility info\ninfo = UtilInfo(\n    version=1234567,\n    protocolversion=70016,\n    walletversion=60000,\n    balance=1.23456789,\n    blocks=123456,\n    timeoffset=0,\n    connections=8,\n    proxy=\"\",\n    difficulty=1.23456789,\n    testnet=False,\n    keypoololdest=1234567890,\n    keypoolsize=1000,\n    unlocked_until=0,\n    paytxfee=0.00001,\n    relayfee=0.00001,\n    errors=\"\"\n)\n\n# Access properties\nprint(info.version)  # 1234567\nprint(info.balance)  # 1.23456789\nprint(info.blocks)  # 123456\n</code></pre>"},{"location":"models/#websocket-models","title":"WebSocket Models","text":"<p>The WebSocket models are defined in the <code>evrmore_rpc.websockets.models</code> module.</p>"},{"location":"models/#websocketmessage","title":"WebSocketMessage","text":"<p>The <code>WebSocketMessage</code> model represents a WebSocket message.</p> <pre><code>from evrmore_rpc.websockets.models import WebSocketMessage\n\n# Create a WebSocket message\nmessage = WebSocketMessage(\n    type=\"block\",\n    data={\n        \"hash\": \"hash\",\n        \"height\": 123456,\n        \"time\": 1234567890\n    }\n)\n\n# Access properties\nprint(message.type)  # \"block\"\nprint(message.data[\"hash\"])  # \"hash\"\nprint(message.data[\"height\"])  # 123456\n</code></pre>"},{"location":"models/#websocketsubscription","title":"WebSocketSubscription","text":"<p>The <code>WebSocketSubscription</code> model represents a WebSocket subscription.</p> <pre><code>from evrmore_rpc.websockets.models import WebSocketSubscription\n\n# Create a WebSocket subscription\nsubscription = WebSocketSubscription(\n    topic=\"blocks\",\n    client_id=\"client_id\"\n)\n\n# Access properties\nprint(subscription.topic)  # \"blocks\"\nprint(subscription.client_id)  # \"client_id\"\n</code></pre>"},{"location":"models/#zmq-models","title":"ZMQ Models","text":"<p>The ZMQ models are defined in the <code>evrmore_rpc.zmq.models</code> module.</p>"},{"location":"models/#zmqnotification","title":"ZMQNotification","text":"<p>The <code>ZMQNotification</code> model represents a ZMQ notification.</p> <pre><code>from evrmore_rpc.zmq.models import ZMQNotification\nfrom evrmore_rpc.zmq.client import ZMQTopic\n\n# Create a ZMQ notification\nnotification = ZMQNotification(\n    topic=ZMQTopic.HASH_BLOCK,\n    body=b\"block_hash\",\n    sequence=123456\n)\n\n# Access properties\nprint(notification.topic)  # ZMQTopic.HASH_BLOCK\nprint(notification.body)  # b\"block_hash\"\nprint(notification.sequence)  # 123456\nprint(notification.hex)  # \"626c6f636b5f68617368\" (hexadecimal representation of body)\n</code></pre>"},{"location":"sync_api/","title":"Synchronous API","text":"<p>The <code>evrmore-rpc</code> package provides a synchronous API for interacting with the Evrmore blockchain.</p>"},{"location":"sync_api/#installation","title":"Installation","text":"<pre><code>pip install evrmore-rpc\n</code></pre>"},{"location":"sync_api/#evrmorerpcclient-class","title":"EvrmoreRPCClient Class","text":"<p>The <code>EvrmoreRPCClient</code> class is the main entry point for the synchronous API. It provides a clean interface with autocomplete support for all Evrmore RPC commands.</p>"},{"location":"sync_api/#initialization","title":"Initialization","text":"<pre><code>from evrmore_rpc import EvrmoreRPCClient\n\n# Create a client with default settings\nclient = EvrmoreRPCClient()\n\n# Create a client with custom settings\nclient = EvrmoreRPCClient(\n    datadir=\"/path/to/evrmore/data\",\n    rpcuser=\"username\",\n    rpcpassword=\"password\",\n    rpcport=8819,\n    testnet=False\n)\n</code></pre>"},{"location":"sync_api/#parameters","title":"Parameters","text":"<ul> <li><code>datadir</code> (Optional[Path]): Path to the Evrmore data directory</li> <li><code>rpcuser</code> (Optional[str]): RPC username</li> <li><code>rpcpassword</code> (Optional[str]): RPC password</li> <li><code>rpcport</code> (Optional[int]): RPC port</li> <li><code>testnet</code> (bool): Whether to use testnet (default: False)</li> </ul>"},{"location":"sync_api/#blockchain-commands","title":"Blockchain Commands","text":"<pre><code>from evrmore_rpc import EvrmoreRPCClient\n\nclient = EvrmoreRPCClient()\n\n# Get blockchain info\ninfo = client.getblockchaininfo()\nprint(f\"Current block height: {info.blocks}\")\nprint(f\"Chain: {info.chain}\")\nprint(f\"Difficulty: {info.difficulty}\")\n\n# Get a block by height\nheight = 100\nblock_hash = client.getblockhash(height)\nblock = client.getblock(block_hash)\nprint(f\"Block hash: {block.hash}\")\nprint(f\"Block time: {block.time}\")\nprint(f\"Transactions: {len(block.tx)}\")\n</code></pre>"},{"location":"sync_api/#asset-commands","title":"Asset Commands","text":"<pre><code>from evrmore_rpc import EvrmoreRPCClient\n\nclient = EvrmoreRPCClient()\n\n# List assets\nassets = client.listassets()\nfor name, amount in assets.items():\n    print(f\"Asset: {name}, Supply: {amount}\")\n\n# Get asset data\nasset_data = client.getassetdata(\"ASSET_NAME\")\nprint(f\"Asset: {asset_data.name}\")\nprint(f\"Amount: {asset_data.amount}\")\nprint(f\"Units: {asset_data.units}\")\nprint(f\"Reissuable: {asset_data.reissuable}\")\n\n# Issue a new asset\ntxid = client.issue(\n    asset_name=\"NEW_ASSET\",\n    qty=1000,\n    to_address=\"EVRaddress\",\n    units=0,\n    reissuable=True,\n    has_ipfs=False\n)\nprint(f\"Asset issued with transaction ID: {txid}\")\n\n# Transfer an asset\ntxid = client.transfer(\n    asset_name=\"ASSET_NAME\",\n    qty=100,\n    to_address=\"EVRaddress\"\n)\nprint(f\"Asset transferred with transaction ID: {txid}\")\n</code></pre>"},{"location":"sync_api/#wallet-commands","title":"Wallet Commands","text":"<pre><code>from evrmore_rpc import EvrmoreRPCClient\n\nclient = EvrmoreRPCClient()\n\n# Get wallet info\nwallet_info = client.getwalletinfo()\nprint(f\"Balance: {wallet_info.balance}\")\nprint(f\"Unconfirmed balance: {wallet_info.unconfirmed_balance}\")\nprint(f\"Immature balance: {wallet_info.immature_balance}\")\n\n# Send to address\ntxid = client.sendtoaddress(\"EVRaddress\", 1.0, \"payment\", \"from\", False)\nprint(f\"Transaction ID: {txid}\")\n\n# List transactions\ntransactions = client.listtransactions()\nfor tx in transactions:\n    print(f\"Transaction: {tx.txid}\")\n    print(f\"Amount: {tx.amount}\")\n    print(f\"Confirmations: {tx.confirmations}\")\n</code></pre>"},{"location":"sync_api/#raw-transaction-commands","title":"Raw Transaction Commands","text":"<pre><code>from evrmore_rpc import EvrmoreRPCClient\n\nclient = EvrmoreRPCClient()\n\n# Create a raw transaction\ninputs = [{\"txid\": \"txid\", \"vout\": 0}]\noutputs = {\"EVRaddress\": 1.0}\nraw_tx = client.createrawtransaction(inputs, outputs)\n\n# Sign the raw transaction\nsigned_tx = client.signrawtransaction(raw_tx)\n\n# Send the raw transaction\ntxid = client.sendrawtransaction(signed_tx.hex)\nprint(f\"Transaction ID: {txid}\")\n</code></pre>"},{"location":"sync_api/#error-handling","title":"Error Handling","text":"<p>The <code>EvrmoreRPCClient</code> class raises <code>EvrmoreRPCError</code> exceptions when an error occurs.</p> <pre><code>from evrmore_rpc import EvrmoreRPCClient, EvrmoreRPCError\n\nclient = EvrmoreRPCClient()\n\ntry:\n    # Try to get a non-existent block\n    block = client.getblock(\"invalid_hash\")\nexcept EvrmoreRPCError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"sync_api/#direct-command-execution","title":"Direct Command Execution","text":"<p>The <code>EvrmoreRPCClient</code> class also provides a <code>execute_command</code> method for executing commands directly.</p> <pre><code>from evrmore_rpc import EvrmoreRPCClient\n\nclient = EvrmoreRPCClient()\n\n# Execute a command directly\nresult = client.execute_command(\"getblockchaininfo\")\nprint(f\"Chain: {result['chain']}\")\n</code></pre>"},{"location":"sync_api/#command-line-interface","title":"Command Line Interface","text":"<p>The <code>evrmore-rpc</code> package also provides a command-line interface for executing RPC commands.</p> <pre><code># Get blockchain info\nevrmore-rpc getblockchaininfo\n\n# Get a block by height\nevrmore-rpc getblockhash 100 | evrmore-rpc getblock -\n\n# List assets\nevrmore-rpc listassets\n</code></pre> <p>For more information on the command-line interface, see the CLI documentation. </p>"},{"location":"websockets/","title":"WebSockets Support","text":"<p>The <code>evrmore-rpc</code> package provides WebSockets support for real-time communication with clients. This allows you to build applications that can push blockchain events to web clients as they happen.</p>"},{"location":"websockets/#installation","title":"Installation","text":"<pre><code>pip install evrmore-rpc\n</code></pre>"},{"location":"websockets/#websocket-server","title":"WebSocket Server","text":"<p>The <code>EvrmoreWebSocketServer</code> class provides a WebSocket server that can broadcast blockchain events to connected clients.</p>"},{"location":"websockets/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreRPCClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient\nfrom evrmore_rpc.websockets import EvrmoreWebSocketServer\n\nasync def main():\n    # Create RPC client\n    rpc_client = EvrmoreRPCClient()\n\n    # Create ZMQ client\n    zmq_client = EvrmoreZMQClient()\n\n    # Create WebSocket server\n    server = EvrmoreWebSocketServer(\n        rpc_client=rpc_client,\n        zmq_client=zmq_client,\n        host=\"localhost\",\n        port=8765\n    )\n\n    # Start the server\n    await server.start()\n    print(f\"WebSocket server started on ws://{server.host}:{server.port}\")\n\n    # Keep the server running until interrupted\n    try:\n        while True:\n            await asyncio.sleep(1)\n    finally:\n        # Stop the server\n        await server.stop()\n        print(\"WebSocket server stopped\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"websockets/#initialization","title":"Initialization","text":"<pre><code>from evrmore_rpc import EvrmoreRPCClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient\nfrom evrmore_rpc.websockets import EvrmoreWebSocketServer\n\n# Create clients\nrpc_client = EvrmoreRPCClient()\nzmq_client = EvrmoreZMQClient()\n\n# Create server with default settings (localhost:8765)\nserver = EvrmoreWebSocketServer(\n    rpc_client=rpc_client,\n    zmq_client=zmq_client\n)\n\n# Create server with custom settings\nserver = EvrmoreWebSocketServer(\n    rpc_client=rpc_client,\n    zmq_client=zmq_client,\n    host=\"0.0.0.0\",  # Listen on all interfaces\n    port=8765,\n    ping_interval=30,  # Send ping every 30 seconds\n    ping_timeout=10    # Wait 10 seconds for pong response\n)\n</code></pre>"},{"location":"websockets/#parameters","title":"Parameters","text":"<ul> <li><code>rpc_client</code> (EvrmoreRPCClient): The RPC client to use for blockchain queries</li> <li><code>zmq_client</code> (EvrmoreZMQClient): The ZMQ client to use for real-time notifications</li> <li><code>host</code> (str): The host to bind the WebSocket server to (default: \"localhost\")</li> <li><code>port</code> (int): The port to bind the WebSocket server to (default: 8765)</li> <li><code>ping_interval</code> (Optional[float]): How often to ping clients in seconds (default: 20)</li> <li><code>ping_timeout</code> (Optional[float]): How long to wait for pong response in seconds (default: 20)</li> </ul>"},{"location":"websockets/#starting-and-stopping","title":"Starting and Stopping","text":"<p>The <code>EvrmoreWebSocketServer</code> class provides methods for starting and stopping the server:</p> <pre><code>import asyncio\nfrom evrmore_rpc import EvrmoreRPCClient\nfrom evrmore_rpc.zmq import EvrmoreZMQClient\nfrom evrmore_rpc.websockets import EvrmoreWebSocketServer\n\nasync def main():\n    # Create clients\n    rpc_client = EvrmoreRPCClient()\n    zmq_client = EvrmoreZMQClient()\n\n    # Create server\n    server = EvrmoreWebSocketServer(\n        rpc_client=rpc_client,\n        zmq_client=zmq_client\n    )\n\n    # Start the server\n    await server.start()\n    print(f\"WebSocket server started on ws://{server.host}:{server.port}\")\n\n    # Keep running for a while\n    await asyncio.sleep(60)\n\n    # Stop the server\n    await server.stop()\n    print(\"WebSocket server stopped\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"websockets/#websocket-client","title":"WebSocket Client","text":"<p>The <code>EvrmoreWebSocketClient</code> class provides a WebSocket client that can connect to an <code>EvrmoreWebSocketServer</code> and receive real-time blockchain events.</p>"},{"location":"websockets/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom evrmore_rpc.websockets import EvrmoreWebSocketClient\n\nasync def main():\n    # Create a WebSocket client\n    client = EvrmoreWebSocketClient(uri=\"ws://localhost:8765\")\n\n    # Connect to the WebSocket server\n    await client.connect()\n\n    # Subscribe to block and transaction notifications\n    await client.subscribe(\"blocks\")\n    await client.subscribe(\"transactions\")\n\n    # Process incoming messages\n    async for message in client:\n        if message.type == \"block\":\n            block_data = message.data\n            print(f\"New block: {block_data.hash} (height: {block_data.height})\")\n\n        elif message.type == \"transaction\":\n            tx_data = message.data\n            print(f\"New transaction: {tx_data.txid}\")\n\n    # Disconnect\n    await client.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"websockets/#initialization_1","title":"Initialization","text":"<pre><code>from evrmore_rpc.websockets import EvrmoreWebSocketClient\n\n# Create a client with default settings\nclient = EvrmoreWebSocketClient()\n\n# Create a client with custom settings\nclient = EvrmoreWebSocketClient(\n    uri=\"ws://example.com:8765\",\n    ping_interval=30,  # Send ping every 30 seconds\n    ping_timeout=10    # Wait 10 seconds for pong response\n)\n</code></pre>"},{"location":"websockets/#parameters_1","title":"Parameters","text":"<ul> <li><code>uri</code> (str): The WebSocket server URI (default: \"ws://localhost:8765\")</li> <li><code>ping_interval</code> (Optional[float]): How often to ping the server in seconds (default: 20)</li> <li><code>ping_timeout</code> (Optional[float]): How long to wait for pong response in seconds (default: 20)</li> </ul>"},{"location":"websockets/#connecting-and-disconnecting","title":"Connecting and Disconnecting","text":"<p>The <code>EvrmoreWebSocketClient</code> class provides methods for connecting to and disconnecting from a WebSocket server:</p> <pre><code>import asyncio\nfrom evrmore_rpc.websockets import EvrmoreWebSocketClient\n\nasync def main():\n    # Create a client\n    client = EvrmoreWebSocketClient()\n\n    # Connect to the server\n    await client.connect()\n    print(\"Connected to WebSocket server\")\n\n    # Keep connected for a while\n    await asyncio.sleep(60)\n\n    # Disconnect\n    await client.disconnect()\n    print(\"Disconnected from WebSocket server\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"websockets/#subscribing-to-topics","title":"Subscribing to Topics","text":"<p>The <code>EvrmoreWebSocketClient</code> class provides methods for subscribing to and unsubscribing from topics:</p> <pre><code>import asyncio\nfrom evrmore_rpc.websockets import EvrmoreWebSocketClient\n\nasync def main():\n    # Create a client\n    client = EvrmoreWebSocketClient()\n\n    # Connect to the server\n    await client.connect()\n\n    # Subscribe to topics\n    await client.subscribe(\"blocks\")\n    await client.subscribe(\"transactions\")\n    await client.subscribe(\"assets\")\n\n    # Process messages for a while\n    for _ in range(10):\n        message = await client.receive()\n        print(f\"Received message: {message.type}\")\n\n    # Unsubscribe from a topic\n    await client.unsubscribe(\"transactions\")\n\n    # Process more messages\n    for _ in range(5):\n        message = await client.receive()\n        print(f\"Received message: {message.type}\")\n\n    # Disconnect\n    await client.disconnect()\n\nasyncio.run(main())\n</code></pre>"},{"location":"websockets/#receiving-messages","title":"Receiving Messages","text":"<p>The <code>EvrmoreWebSocketClient</code> class provides methods for receiving messages:</p> <pre><code>import asyncio\nfrom evrmore_rpc.websockets import EvrmoreWebSocketClient\n\nasync def main():\n    # Create a client\n    client = EvrmoreWebSocketClient()\n\n    # Connect to the server\n    await client.connect()\n\n    # Subscribe to topics\n    await client.subscribe(\"blocks\")\n    await client.subscribe(\"transactions\")\n\n    # Receive a single message\n    message = await client.receive()\n    print(f\"Received message: {message.type}\")\n\n    # Receive messages in a loop\n    try:\n        while True:\n            message = await client.receive()\n            print(f\"Received message: {message.type}\")\n    except asyncio.CancelledError:\n        # Handle cancellation\n        pass\n    finally:\n        # Disconnect\n        await client.disconnect()\n\nasyncio.run(main())\n</code></pre>"},{"location":"websockets/#async-iterator","title":"Async Iterator","text":"<p>The <code>EvrmoreWebSocketClient</code> class also supports the async iterator protocol, which makes it easy to process messages in a loop:</p> <pre><code>import asyncio\nfrom evrmore_rpc.websockets import EvrmoreWebSocketClient\n\nasync def main():\n    # Create a client\n    client = EvrmoreWebSocketClient()\n\n    # Connect to the server\n    await client.connect()\n\n    # Subscribe to topics\n    await client.subscribe(\"blocks\")\n    await client.subscribe(\"transactions\")\n\n    # Process messages using async for\n    try:\n        async for message in client:\n            print(f\"Received message: {message.type}\")\n\n            # Process message based on type\n            if message.type == \"block\":\n                block_data = message.data\n                print(f\"New block: {block_data.hash} (height: {block_data.height})\")\n\n            elif message.type == \"transaction\":\n                tx_data = message.data\n                print(f\"New transaction: {tx_data.txid}\")\n    except asyncio.CancelledError:\n        # Handle cancellation\n        pass\n    finally:\n        # Disconnect\n        await client.disconnect()\n\nasyncio.run(main())\n</code></pre>"},{"location":"websockets/#websocket-message-format","title":"WebSocket Message Format","text":"<p>The WebSocket messages exchanged between the server and clients follow a specific format.</p>"},{"location":"websockets/#server-to-client-messages","title":"Server to Client Messages","text":"<p>Messages sent from the server to clients have the following format:</p> <pre><code>{\n    \"type\": \"block\",\n    \"data\": {\n        \"hash\": \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\",\n        \"height\": 1,\n        \"time\": 1231006505,\n        \"tx_count\": 1,\n        \"size\": 285\n    }\n}\n</code></pre> <p>The <code>type</code> field indicates the type of message, and the <code>data</code> field contains the message data.</p>"},{"location":"websockets/#block-messages","title":"Block Messages","text":"<p>Block messages have the following format:</p> <pre><code>{\n    \"type\": \"block\",\n    \"data\": {\n        \"hash\": \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\",\n        \"height\": 1,\n        \"time\": 1231006505,\n        \"tx_count\": 1,\n        \"size\": 285\n    }\n}\n</code></pre>"},{"location":"websockets/#transaction-messages","title":"Transaction Messages","text":"<p>Transaction messages have the following format:</p> <pre><code>{\n    \"type\": \"transaction\",\n    \"data\": {\n        \"txid\": \"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\",\n        \"size\": 285,\n        \"vsize\": 285,\n        \"version\": 1,\n        \"locktime\": 0,\n        \"vin_count\": 1,\n        \"vout_count\": 1\n    }\n}\n</code></pre>"},{"location":"websockets/#asset-messages","title":"Asset Messages","text":"<p>Asset messages have the following format:</p> <pre><code>{\n    \"type\": \"asset\",\n    \"data\": {\n        \"txid\": \"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\",\n        \"asset\": \"ASSET_NAME\",\n        \"amount\": 100,\n        \"type\": \"transfer\"\n    }\n}\n</code></pre>"},{"location":"websockets/#mempool-messages","title":"Mempool Messages","text":"<p>Mempool messages have the following format:</p> <pre><code>{\n    \"type\": \"mempool\",\n    \"data\": {\n        \"size\": 100,\n        \"bytes\": 28500,\n        \"usage\": 112000\n    }\n}\n</code></pre>"},{"location":"websockets/#client-to-server-messages","title":"Client to Server Messages","text":"<p>Messages sent from clients to the server have the following format:</p>"},{"location":"websockets/#subscribe-messages","title":"Subscribe Messages","text":"<pre><code>{\n    \"action\": \"subscribe\",\n    \"topic\": \"blocks\"\n}\n</code></pre>"},{"location":"websockets/#unsubscribe-messages","title":"Unsubscribe Messages","text":"<pre><code>{\n    \"action\": \"unsubscribe\",\n    \"topic\": \"blocks\"\n}\n</code></pre>"},{"location":"websockets/#command-messages","title":"Command Messages","text":"<pre><code>{\n    \"command\": \"getblockchaininfo\",\n    \"params\": []\n}\n</code></pre>"},{"location":"websockets/#advanced-usage","title":"Advanced Usage","text":""},{"location":"websockets/#custom-message-handlers","title":"Custom Message Handlers","text":"<p>You can create custom message handlers for the WebSocket client:</p> <pre><code>import asyncio\nimport json\nfrom evrmore_rpc.websockets import EvrmoreWebSocketClient\n\nclass CustomWebSocketClient(EvrmoreWebSocketClient):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.block_count = 0\n        self.tx_count = 0\n\n    async def handle_block(self, block_data):\n        \"\"\"Handle a block message.\"\"\"\n        self.block_count += 1\n        print(f\"New block: {block_data.hash} (height: {block_data.height})\")\n        print(f\"Total blocks received: {self.block_count}\")\n\n    async def handle_transaction(self, tx_data):\n        \"\"\"Handle a transaction message.\"\"\"\n        self.tx_count += 1\n        print(f\"New transaction: {tx_data.txid}\")\n        print(f\"Total transactions received: {self.tx_count}\")\n\n    async def process_messages(self):\n        \"\"\"Process messages from the server.\"\"\"\n        async for message in self:\n            if message.type == \"block\":\n                await self.handle_block(message.data)\n            elif message.type == \"transaction\":\n                await self.handle_transaction(message.data)\n\nasync def main():\n    # Create a custom client\n    client = CustomWebSocketClient()\n\n    # Connect to the server\n    await client.connect()\n\n    # Subscribe to topics\n    await client.subscribe(\"blocks\")\n    await client.subscribe(\"transactions\")\n\n    # Process messages\n    try:\n        await client.process_messages()\n    except asyncio.CancelledError:\n        pass\n    finally:\n        await client.disconnect()\n\nasyncio.run(main())\n</code></pre>"},{"location":"websockets/#integration-with-web-frameworks","title":"Integration with Web Frameworks","text":"<p>The WebSocket client can be integrated with web frameworks like FastAPI:</p> <pre><code>import asyncio\nfrom fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom fastapi.responses import HTMLResponse\nfrom evrmore_rpc.websockets import EvrmoreWebSocketClient\n\napp = FastAPI()\n\n# HTML for a simple WebSocket client\nhtml = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Evrmore WebSocket Client&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Evrmore WebSocket Client&lt;/h1&gt;\n        &lt;div id=\"messages\"&gt;&lt;/div&gt;\n        &lt;script&gt;\n            var ws = new WebSocket(\"ws://localhost:8000/ws\");\n            ws.onmessage = function(event) {\n                var messages = document.getElementById('messages');\n                var message = document.createElement('p');\n                message.textContent = event.data;\n                messages.appendChild(message);\n            };\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n@app.get(\"/\")\nasync def get():\n    return HTMLResponse(html)\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n\n    # Create a WebSocket client to connect to the Evrmore WebSocket server\n    client = EvrmoreWebSocketClient()\n\n    try:\n        # Connect to the Evrmore WebSocket server\n        await client.connect()\n\n        # Subscribe to topics\n        await client.subscribe(\"blocks\")\n        await client.subscribe(\"transactions\")\n\n        # Forward messages from the Evrmore WebSocket server to the web client\n        async for message in client:\n            await websocket.send_text(f\"{message.type}: {message.data}\")\n\n    except WebSocketDisconnect:\n        # Web client disconnected\n        pass\n    except Exception as e:\n        # Handle other exceptions\n        print(f\"Error: {e}\")\n    finally:\n        # Disconnect from the Evrmore WebSocket server\n        await client.disconnect()\n</code></pre>"},{"location":"websockets/#custom-websocket-server","title":"Custom WebSocket Server","text":"<p>You can create a custom WebSocket server that extends the functionality of <code>EvrmoreWebSocketServer</code>:</p> <p>```python import asyncio import json import logging from typing import Dict, Set, Any</p> <p>from evrmore_rpc import EvrmoreRPCClient from evrmore_rpc.zmq import EvrmoreZMQClient from evrmore_rpc.websockets import EvrmoreWebSocketServer</p>"},{"location":"websockets/#configure-logging","title":"Configure logging","text":"<p>logging.basicConfig(level=logging.INFO) logger = logging.getLogger(\"custom-websocket-server\")</p> <p>class CustomWebSocketServer(EvrmoreWebSocketServer):     def init(self, args, kwargs):         super().init(args, **kwargs)         self.custom_topics = {             \"large_blocks\": set(),             \"asset_transfers\": set()         }</p> <pre><code>async def handle_block(self, notification):\n    \"\"\"Handle a block notification.\"\"\"\n    # Call the parent method to handle the notification\n    await super().handle_block(notification)\n\n    # Get block details\n    block_hash = notification.hex\n    block = self.rpc_client.getblock(block_hash)\n\n    # Check if this is a large block\n    if len(block.tx) &gt; 100:\n        # Prepare message\n        message = {\n            \"type\": \"large_block\",\n            \"data\": {\n                \"hash\": block.hash,\n                \"height\": block.height,\n                \"time\": block.time,\n                \"tx_count\": len(block.tx),\n                \"size\": block.size\n            }\n        }\n\n        # Broadcast to subscribers\n        await self.broadcast(\"large_blocks\", message)\n\nasync def handle_transaction(self, notification):\n    \"\"\"Handle a transaction notification.\"\"\"\n    # Call the parent method to handle the notification\n    await super().handle_transaction(notification)\n\n    # Get transaction details\n    txid = notification.hex\n\n    try:\n        tx = self.rpc_client.getrawtransaction(txid, True)\n\n        # Check for asset transfers\n        for vout in tx.vout:\n            if \"asset\" in vout.get(\"scriptPubKey\", {}).get(\"asset\", {}):\n                asset = vout[\"scriptPubKey\"][\"asset\"]\n\n                # Prepare asset message\n                asset_message = {\n                    \"type\": \"asset_transfer\",\n                    \"data\": {\n                        \"txid\": tx.txid,\n                        \"asset\": asset[\"name\"],\n                        \"amount\": asset[\"amount\"],\n                        \"from\": \"unknown\",  # Would need to look up the input address\n                        \"to\": vout[\"scriptPubKey\"].get(\"addresses\", [\"unknown\"])[0]\n                    }\n                }\n\n                # Broadcast to asset transfer subscribers\n                await self.broadcast(\"asset_transfers\", asset_message)\n    except Exception as e:\n        logger.error(f\"Error handling transaction: {e}\")\n\nasync def handle_client_message(self, websocket, message):\n    \"\"\"Handle a message from a client.\"\"\"\n    try:\n        data = json.loads(message)\n\n        # Handle custom subscriptions\n        if \"action\" in data and \"topic\" in data:\n            action = data[\"action\"]\n            topic = data[\"topic\"]\n\n            if topic in self.custom_topics:\n                if action == \"subscribe\":\n                    self.custom_topics[topic].add(websocket)\n                    await websocket.send(json.dumps({\n                        \"type\": \"subscription\",\n                        \"status\": \"success\",\n                        \"topic\": topic\n                    }))\n                    logger.info(f\"Client subscribed to custom topic: {topic}\")\n                elif action == \"unsubscribe\":\n                    if websocket in self.custom_topics[topic]:\n                        self.custom_topics[topic].remove(websocket)\n                        await websocket.send(json.dumps({\n                            \"type\": \"subscription\",\n                            \"status\": \"success\",\n                            \"topic\": topic,\n                            \"action\": \"unsubscribe\"\n                        }))\n                        logger.info(f\"Client unsubscribed from custom topic: {topic}\")\n                return True\n\n        # If not handled, let the parent class handle it\n        return await super().handle_client_message(websocket, message)\n\n    except json.JSONDecodeError:\n        await websocket.send(json.dumps({\n            \"type\": \"error\",\n            \"message\": \"Invalid JSON\"\n        }))\n        return True\n\nasync def broadcast(self, topic, message):\n    \"\"\"Broadcast a message to subscribers of a topic.\"\"\"\n    if topic in self.subscriptions:\n        # Use the parent method for standard topics\n        await super().broadcast(topic, message)\n    elif topic in self.custom_topics:\n        # Handle custom topics\n        subscribers = self.custom_topics[topic]\n        if subscribers:\n            message_str = json.dumps(message)\n            await asyncio.gather(\n                *[client.send(message_str) for client in subscribers],\n                return_exceptions=True\n            )\n</code></pre> <p>async def main():     # Create clients     rpc_client = EvrmoreRPCClient()     zmq_client = EvrmoreZMQClient()</p> <pre><code># Create custom server\nserver = CustomWebSocketServer(\n    rpc_client=rpc_client,\n    zmq_client=zmq_client\n)\n\n# Start the server\nawait server.start()\nprint(f\"Custom WebSocket server started on ws://{server.host}:{server.port}\")\n\n# Keep running until interrupted\ntry:\n    while True:\n        await asyncio.sleep(1)\nexcept KeyboardInterrupt:\n    print(\"Interrupted by user\")\nfinally:\n    await server.stop()\n    print(\"Custom WebSocket server stopped\")\n</code></pre> <p>if name == \"main\":     asyncio.run(main()) </p>"},{"location":"zmq/","title":"ZMQ Support","text":"<p>The <code>evrmore-rpc</code> package provides ZMQ (ZeroMQ) support for receiving real-time notifications from the Evrmore blockchain. This allows you to build applications that can react to new blocks, transactions, and other blockchain events as they happen.</p>"},{"location":"zmq/#installation","title":"Installation","text":"<pre><code>pip install evrmore-rpc\n</code></pre>"},{"location":"zmq/#evrmore-node-configuration","title":"Evrmore Node Configuration","text":"<p>To use ZMQ with Evrmore, you need to configure your Evrmore node to publish ZMQ notifications. Add the following to your <code>evrmore.conf</code> file:</p> <pre><code># ZMQ notifications\nzmqpubhashtx=tcp://127.0.0.1:28332\nzmqpubhashblock=tcp://127.0.0.1:28332\nzmqpubrawtx=tcp://127.0.0.1:28332\nzmqpubrawblock=tcp://127.0.0.1:28332\nzmqpubsequence=tcp://127.0.0.1:28332\n</code></pre> <p>Then restart your Evrmore node for the changes to take effect.</p>"},{"location":"zmq/#evrmorezmqclient","title":"EvrmoreZMQClient","text":"<p>The <code>EvrmoreZMQClient</code> class provides a simple interface for receiving ZMQ notifications from an Evrmore node.</p>"},{"location":"zmq/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\nasync def handle_block(notification):\n    print(f\"New block: {notification.hex}\")\n\nasync def handle_transaction(notification):\n    print(f\"New transaction: {notification.hex}\")\n\nasync def main():\n    # Create a ZMQ client\n    client = EvrmoreZMQClient(\n        address=\"tcp://127.0.0.1:28332\",\n        topics=[ZMQTopic.HASH_BLOCK, ZMQTopic.HASH_TX]\n    )\n\n    # Register handlers\n    client.on_block(handle_block)\n    client.on_transaction(handle_transaction)\n\n    # Start the client\n    await client.start()\n\n    # Keep running until interrupted\n    try:\n        while True:\n            await asyncio.sleep(1)\n    finally:\n        await client.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"zmq/#initialization","title":"Initialization","text":"<pre><code>from evrmore_rpc.zmq import EvrmoreZMQClient, ZMQTopic\n\n# Create a client with default settings (localhost:28332)\nclient = EvrmoreZMQClient()\n\n# Create a client with custom settings\nclient = EvrmoreZMQClient(\n    address=\"tcp://127.0.0.1:28332\",\n    topics=[ZMQTopic.HASH_BLOCK, ZMQTopic.HASH_TX, ZMQTopic.RAW_BLOCK, ZMQTopic.RAW_TX, ZMQTopic.SEQUENCE]\n)\n\n# Create a client with a custom ZMQ context\nimport zmq.asyncio\ncontext = zmq.asyncio.Context()\nclient = EvrmoreZMQClient(\n    address=\"tcp://127.0.0.1:28332\",\n    context=context\n)\n</code></pre>"},{"location":"zmq/#parameters","title":"Parameters","text":"<ul> <li><code>address</code> (str): The ZMQ endpoint address (default: \"tcp://127.0.0.1:28332\")</li> <li><code>context</code> (Optional[zmq.asyncio.Context]): A custom ZMQ context (default: None)</li> <li><code>topics</code> (List[ZMQTopic]): The topics to subscribe to (default: all topics)</li> </ul>"},{"location":"zmq/#zmqtopic-enum","title":"ZMQTopic Enum","text":"<p>The <code>ZMQTopic</code> enum defines the available ZMQ notification topics:</p> <ul> <li><code>HASH_TX</code>: Transaction hash notifications</li> <li><code>HASH_BLOCK</code>: Block hash notifications</li> <li><code>RAW_TX</code>: Raw transaction notifications</li> <li><code>RAW_BLOCK</code>: Raw block notifications</li> <li><code>SEQUENCE</code>: Sequence notifications</li> </ul>"},{"location":"zmq/#registering-handlers","title":"Registering Handlers","text":"<p>You can register handlers for specific notification types using the following decorators:</p> <pre><code>from evrmore_rpc.zmq import EvrmoreZMQClient\n\nclient = EvrmoreZMQClient()\n\n@client.on_block\nasync def handle_block(notification):\n    print(f\"New block: {notification.hex}\")\n\n@client.on_transaction\nasync def handle_transaction(notification):\n    print(f\"New transaction: {notification.hex}\")\n\n@client.on_raw_block\nasync def handle_raw_block(notification):\n    print(f\"New raw block: {len(notification.body)} bytes\")\n\n@client.on_raw_transaction\nasync def handle_raw_transaction(notification):\n    print(f\"New raw transaction: {len(notification.body)} bytes\")\n\n@client.on_sequence\nasync def handle_sequence(notification):\n    print(f\"New sequence: {notification.hex}\")\n</code></pre> <p>Alternatively, you can register handlers using the method syntax:</p> <pre><code>async def handle_block(notification):\n    print(f\"New block: {notification.hex}\")\n\nasync def handle_transaction(notification):\n    print(f\"New transaction: {notification.hex}\")\n\nclient.on_block(handle_block)\nclient.on_transaction(handle_transaction)\n</code></pre>"},{"location":"zmq/#zmqnotification-object","title":"ZMQNotification Object","text":"<p>The <code>ZMQNotification</code> object passed to handlers has the following properties:</p> <ul> <li><code>topic</code> (ZMQTopic): The notification topic</li> <li><code>body</code> (bytes): The notification body (raw data)</li> <li><code>sequence</code> (Optional[int]): The notification sequence number (if available)</li> <li><code>hex</code> (str): The notification body as a hexadecimal string</li> </ul>"},{"location":"zmq/#starting-and-stopping","title":"Starting and Stopping","text":"<p>The <code>EvrmoreZMQClient</code> class provides methods for starting and stopping the client:</p> <pre><code>import asyncio\nfrom evrmore_rpc.zmq import EvrmoreZMQClient\n\nasync def main():\n    client = EvrmoreZMQClient()\n\n    # Register handlers\n    # ...\n\n    # Start the client\n    await client.start()\n\n    # Keep running for a while\n    await asyncio.sleep(60)\n\n    # Stop the client\n    await client.stop()\n\nasyncio.run(main())\n</code></pre>"},{"location":"zmq/#async-context-manager","title":"Async Context Manager","text":"<p>The <code>EvrmoreZMQClient</code> class supports the async context manager protocol, which ensures proper cleanup of resources:</p> <pre><code>import asyncio\nfrom evrmore_rpc.zmq import EvrmoreZMQClient\n\nasync def main():\n    async with EvrmoreZMQClient() as client:\n        # Register handlers\n        @client.on_block\n        async def handle_block(notification):\n            print(f\"New block: {notification.hex}\")\n\n        # Keep running for a while\n        await asyncio.sleep(60)\n\nasyncio.run(main())\n</code></pre>"},{"location":"zmq/#advanced-usage","title":"Advanced Usage","text":""},{"location":"zmq/#custom-zmq-context","title":"Custom ZMQ Context","text":"<p>You can provide a custom ZMQ context to the <code>EvrmoreZMQClient</code> constructor:</p> <pre><code>import zmq.asyncio\nfrom evrmore_rpc.zmq import EvrmoreZMQClient\n\n# Create a custom ZMQ context\ncontext = zmq.asyncio.Context()\n\n# Create a ZMQ client with the custom context\nclient = EvrmoreZMQClient(\n    address=\"tcp://127.0.0.1:28332\",\n    context=context\n)\n</code></pre>"},{"location":"zmq/#multiple-handlers","title":"Multiple Handlers","text":"<p>You can register multiple handlers for the same notification type:</p> <pre><code>from evrmore_rpc.zmq import EvrmoreZMQClient\n\nclient = EvrmoreZMQClient()\n\n@client.on_block\nasync def log_block(notification):\n    print(f\"New block: {notification.hex}\")\n\n@client.on_block\nasync def save_block(notification):\n    # Save the block to a database\n    pass\n\n@client.on_block\nasync def notify_users(notification):\n    # Notify users about the new block\n    pass\n</code></pre>"},{"location":"zmq/#error-handling","title":"Error Handling","text":"<p>Handlers can raise exceptions, which will be caught and logged by the <code>EvrmoreZMQClient</code>:</p> <pre><code>from evrmore_rpc.zmq import EvrmoreZMQClient\n\nclient = EvrmoreZMQClient()\n\n@client.on_block\nasync def handle_block(notification):\n    # This will raise an exception\n    raise ValueError(\"Something went wrong\")\n</code></pre>"},{"location":"zmq/#integration-with-websockets","title":"Integration with WebSockets","text":"<p>The <code>EvrmoreZMQClient</code> can be integrated with WebSockets to broadcast blockchain events to web clients:</p> <pre><code>import asyncio\nimport websockets\nimport json\nfrom evrmore_rpc.zmq import EvrmoreZMQClient\n\n# Connected WebSocket clients\nclients = set()\n\nasync def register(websocket):\n    clients.add(websocket)\n    try:\n        await websocket.wait_closed()\n    finally:\n        clients.remove(websocket)\n\nasync def broadcast(message):\n    if clients:\n        await asyncio.gather(\n            *[client.send(message) for client in clients]\n        )\n\nasync def zmq_handler():\n    client = EvrmoreZMQClient()\n\n    @client.on_block\n    async def handle_block(notification):\n        message = json.dumps({\n            \"type\": \"block\",\n            \"hash\": notification.hex\n        })\n        await broadcast(message)\n\n    @client.on_transaction\n    async def handle_transaction(notification):\n        message = json.dumps({\n            \"type\": \"transaction\",\n            \"hash\": notification.hex\n        })\n        await broadcast(message)\n\n    await client.start()\n\n    try:\n        while True:\n            await asyncio.sleep(1)\n    finally:\n        await client.stop()\n\nasync def websocket_server(websocket, path):\n    await register(websocket)\n\nasync def main():\n    # Start ZMQ handler\n    asyncio.create_task(zmq_handler())\n\n    # Start WebSocket server\n    async with websockets.serve(websocket_server, \"localhost\", 8765):\n        await asyncio.Future()  # Run forever\n\nasyncio.run(main())\n</code></pre>"},{"location":"zmq/#zmq-utilities","title":"ZMQ Utilities","text":"<p>The <code>evrmore_rpc.zmq.utils</code> module provides utility functions for working with ZMQ notifications:</p>"},{"location":"zmq/#transaction-utilities","title":"Transaction Utilities","text":"<pre><code>from evrmore_rpc.zmq.utils import (\n    get_transaction_hash,\n    get_transaction_inputs,\n    get_transaction_outputs,\n    parse_transaction\n)\n\n# Get transaction hash from raw transaction\ntx_hash = get_transaction_hash(raw_tx_bytes)\n\n# Get transaction inputs from raw transaction\ninputs = get_transaction_inputs(raw_tx_bytes)\n\n# Get transaction outputs from raw transaction\noutputs = get_transaction_outputs(raw_tx_bytes)\n\n# Parse raw transaction into a structured object\ntx = parse_transaction(raw_tx_bytes)\n</code></pre>"},{"location":"zmq/#block-utilities","title":"Block Utilities","text":"<pre><code>from evrmore_rpc.zmq.utils import (\n    get_block_hash,\n    get_block_header,\n    get_block_transactions,\n    parse_block\n)\n\n# Get block hash from raw block\nblock_hash = get_block_hash(raw_block_bytes)\n\n# Get block header from raw block\nheader = get_block_header(raw_block_bytes)\n\n# Get block transactions from raw block\ntransactions = get_block_transactions(raw_block_bytes)\n\n# Parse raw block into a structured object\nblock = parse_block(raw_block_bytes)\n</code></pre>"}]}